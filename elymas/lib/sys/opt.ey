<
  "../compiler/elymasAsm.ey" include

  assembler ":" via

  [
    8 /r15 :subqImm8Reg
    /r15 :popqMem
  ] ==:generalHeaderPattern

  [
    8 /r15 :subqImm8Reg
    0 /rbx :movqImmReg
    /rbx /rsi :movqMemReg
    /rsi /r15 :movqRegMem
    8 /rdi :movqImmReg
    0 /rax :movqImmReg
    /rax :callqReg
    /rax /rbx :movqRegMem
  ] ==:scopingHeaderPattern

  [
    0 /rax :movqImmReg
    /rax :pushqReg
  ] ==:pushConstantPattern

  [
    0 /rax :movqImmReg
    /rax :callqReg
  ] ==:callConstantPattern

  [
    0 :callqRel32
  ] ==:footerPattern

  [
    /rbx :popqReg
    0 /rax :movqImmReg
    /rax :pushqReg
    /rbx :pushqReg
    0 /rax :movqImmReg
    /rax :jmpqReg
  ] ==:constantActiveGeneralPattern

  [
    0 /rsi :movqImmReg
    16 /r15 :subqImm8Reg
    8 /r15 :popqMemDisp8

    0 /rax :movqImmReg
    /rsi /rax :xchgqRegMem
    /rsi /r15 :movqRegMem
    0 /rdi :movqImmReg
    /rdi :callqReg

    /r15 /rsi :movqMemReg
    0 /rax :movqImmReg
    /rsi /rax :movqRegMem

    8 /r15 :pushqMemDisp8
    16 /r15 :addqImm8Reg
    :retn
  ] ==:constantNormalFunctionScopedUntypedPattern

  [
    0 /rax :movqImmReg
    /rax :jmpqReg
  ] ==:constantNormalFunctionUnscopedUntypedPattern

  [
    /rbx :popqReg
    0 /rax :movqImmReg
    /rax :pushqReg
    /rbx :jmpqReg
  ] ==:constantPassivePattern

  [
    0 /rax :movqImmReg
    /rax /rax :movqMemReg
  ] ==:staticLoadPattern

  [
    16 /rax /rax :movqMemDisp8Reg
  ] ==:staticLoadParentPattern

  [
    /rbx :popqReg
    0 /rax /rax :movqMemDisp32Reg
  ] ==:staticLoadFromScopePattern

  [
    24 /rax /rcx :movqMemDisp8Reg # load extension area pointer
    /rax /edx :movlMemReg # load scope length
    /rdx :negqReg # prepare for substraction
    /rbx :popqReg
    0 1 /rdx /rcx /rax :movqMemIndexScaleDisp32Reg # load entry
  ] ==:staticLoadFromExtensionPattern

  [
    /rax :pushqReg
    0 /rcx :movqImmReg
    /rax /rcx :movqRegMem
    /rbx :jmpqReg
  ] ==:staticLoadPassivePattern

  [
    /rax :pushqReg
    0 /rcx :movqImmReg
    /rax /rcx :movqRegMem
    /rbx :pushqReg
    0 /rax :movqImmReg
    /rax :jmpqReg
  ] ==:staticLoadActivePattern

  [
    8 /r15 :subqImm8Reg
    /r15 :popqMem
  ] ==:customFunctionHeaderPattern

  /NOP ==:NOP
  /PUSH ==:PUSH
  /CALL ==:CALL
  /CALLSCOPED ==:CALLSCOPED
  /STATIC ==:STATIC
  /STATICTYPED ==:STATICTYPED
  /STATICWRITE ==:STATICWRITE
  /STATICDOT ==:STATICDOT
  /NATIVE ==:NATIVE

  { =*f ==t
    t { f } { 0 } ? *
  } /andif deffd

  { ==o ==executingScope
    0 ==containsScopeModifications # TODO: replace <, > by macros ( {, scope } * respectively) then remove this

    { _ ==logic
      logic { ==entry 0 entry * ==action
        [
          { action CALL streq { 1 entry * "<" | +rawCodeAddress eq }' andif }' {
            1 =containsScopeModifications
          }

          { action CALL streq { 1 entry * ">" | +rawCodeAddress eq }' andif }' {
            1 =containsScopeModifications
          }
        ] conds
      } each
    } /testScopeModifications deffst

    { ==logic
      [ NOP ] ==last
      [ logic { ==entry 0 entry * ==action
        [
          { action CALL streq { 1 entry * "|" | +rawCodeAddress eq }' andif { 0 last * PUSH streq }' andif }' {
            1 last * +rawObject ==constant

            constant executingScope sys .resolveInfo {
              ==mode -- ==parentCount 32 add ==offsetInScope ==inExtensionArea
              inExtensionArea { offsetInScope 8 add =offsetInScope } rep

              mode 16 div 1 band {
                [ STATIC offsetInScope parentCount inExtensionArea ] =last
                [ NOP ] =entry
              } { } ? *
            } {
              executingScope dump
              executingScope keys dump
              constant dump
              "resolution failed" die
            } ? *
          }
        ] conds

        last
        entry =last
      } each last ]
    } /rewriteConstantPipe deffst

    { ==logic
      [ NOP ] ==last
      [ logic { ==entry 0 entry * ==action
        [
          { action CALL streq { 1 entry * "=" | +rawCodeAddress eq }' andif { 0 last * PUSH streq }' andif }' {
            1 last * +rawObject ==constant

            constant executingScope sys .resolveInfo {
              ==mode -- ==parentCount 32 add ==offsetInScope ==inExtensionArea
              inExtensionArea { offsetInScope 8 add =offsetInScope } rep

              mode 16 div 1 band {
                [ STATICWRITE offsetInScope parentCount inExtensionArea ] =last
                [ NOP ] =entry
              } { } ? *
            } {
              executingScope dump
              executingScope keys dump
              constant dump
              "resolution failed" die
            } ? *
          }
        ] conds

        last
        entry =last
      } each last ]
    } /rewriteConstantEquals deffst

    { _ ==logic
      2 logic len range { ==i i logic * ==entry 0 entry * ==action i 1 sub logic * ==last i 2 sub logic * ==secondLast
        [
          { action CALL streq
            { 1 entry * "." | +rawCodeAddress eq }' andif
            { 0 last * PUSH streq }' andif
            { 0 secondLast * STATICTYPED streq }' andif
          }' {
            1 last * +rawObject ==constant
            4 secondLast * +rawObject ==relevantScope

            constant relevantScope sys .resolveInfo {
              ==mode -- ==parentCount 32 add ==offsetInScope ==inExtensionArea
              inExtensionArea { offsetInScope 8 add =offsetInScope } rep

              mode 16 div 1 band {
                [ STATICDOT offsetInScope parentCount inExtensionArea ] i 1 sub logic =[]
                mode 1 band { # TODO bail out for activation mode of 2
                  [ CALL "*" | +rawCodeAddress ] i logic =[]
                } {
                  [ NOP ] i logic =[]
                } ? *
              } { } ? *
            } {
              relevantScope dump
              relevantScope keys dump
              constant dump
              "resolution failed" die
            } ? *
          }
        ] conds
      } each
    } /rewriteConstantDot deffst

    { ==logic
      [ NOP ] ==last
      [ logic { ==entry 0 entry * ==action
        [
          { action CALL streq { 1 entry * "_" | +rawCodeAddress eq }' andif }' {
            [ NATIVE [
              0 /rsp :pushqMemDisp8
            ] ] =entry
          }
        ] conds

        last
        entry =last
      } each last ]
    } /rewriteStackOps deffst

    sys .asm "+" via
    sys .asm .|peek ==:peek
    sys .opt "::" via

    o +rawAddress ==addr
    # "Addr: " dump addr dump
    [ addr       _ 4 add range peek each ] 256 math .unbase ==totalLength
    [ addr 8 add _ 4 add range peek each ] 256 math .unbase ==codeLength
    # "Total length: " dump totalLength dump
    # "Code length: " dump codeLength dump
    addr 16 add ==i

    { =*ops =*set =*get ==pattern
      1 ==found
      get ==j
      pattern { _ j ops -01 { eq not { 0 =found }' rep }" { -- -- }" ? * j 1 add =j }' each
      found _ { j set }' { }" ? *
    } /generalMatch deff

    { { i }' { =i }' peek generalMatch }' /match deff

    generalHeaderPattern match not { "failure while matching generalHeaderPattern" die }" rep
    scopingHeaderPattern match ==isScoping

    1 ==continueParsing

    [ ] ==newLogic
    { newLogic [ -102 ] cat =newLogic }' /emitLogic deffst

    { continueParsing }' { i ==s
      [
        { footerPattern match }' {
          0 =continueParsing
        }

        { pushConstantPattern match }' {
          [ s 2 add _ 8 add range peek each ] 256 math .unbase ==pushedConstant

          [ PUSH pushedConstant ] emitLogic
        }

        { callConstantPattern match }' {
          [ s 2 add _ 8 add range peek each ] 256 math .unbase ==calledAddress
          calledAddress ==j
          { { j }' { =j }' peek generalMatch }' /callTargetMatch deff
          [
            { constantActiveGeneralPattern callTargetMatch }' {
              [ calledAddress 3 add _ 8 add range peek each ] 256 math .unbase ==calledConstant

              [ PUSH calledConstant ] emitLogic
              [ CALL "*" | +rawCodeAddress ] emitLogic
            }

            { constantNormalFunctionScopedUntypedPattern callTargetMatch }' {
              [ calledAddress  2 add _ 8 add range peek each ] 256 math .unbase ==functionScope
              [ calledAddress 36 add _ 8 add range peek each ] 256 math .unbase ==finalAddress

              [ CALLSCOPED finalAddress functionScope ] emitLogic
            }

            { constantNormalFunctionUnscopedUntypedPattern callTargetMatch }' {
              [ calledAddress 2 add _ 8 add range peek each ] 256 math .unbase ==finalAddress

              [ CALL finalAddress ] emitLogic
            }

            { constantPassivePattern callTargetMatch }' {
              [ calledAddress 3 add _ 8 add range peek each ] 256 math .unbase ==pushedConstant

              [ PUSH pushedConstant ] emitLogic
            }

            { staticLoadPattern callTargetMatch }' {
              0 ==parentCount
              { staticLoadParentPattern callTargetMatch }' {
                parentCount 1 add =parentCount
              } loop

              j ==loadStart

              [
                { staticLoadFromScopePattern callTargetMatch }' {
                  [ loadStart 4 add _ 4 add range peek each ] 256 math .unbase ==offsetInScope
                  [ calledAddress 8 sub _ 8 add range peek each ] 256 math .unbase ==exampleObjectOffset
                  [ calledAddress exampleObjectOffset add _ 8 add range peek each ] 256 math .unbase ==exampleObject

                  [ STATICTYPED offsetInScope parentCount 0 exampleObject ] emitLogic
                }

                { staticLoadFromExtensionPattern callTargetMatch }' {
                  [ loadStart 14 add _ 4 add range peek each ] 256 math .unbase ==offsetInScope
                  [ calledAddress 8 sub _ 8 add range peek each ] 256 math .unbase ==exampleObjectOffset
                  [ calledAddress exampleObjectOffset add _ 8 add range peek each ] 256 math .unbase ==exampleObject
                  
                  [ STATICTYPED offsetInScope parentCount 1 exampleObject ] emitLogic
                }

                { 1 }' {
                  [ j j 16 add range peek each ] dump
                  o dump
                  j dump
                  "unparsed static load opcodes in sys .opt .hook (optimizing version)" die
                }
              ] conds

              [
                { staticLoadActivePattern callTargetMatch }' {
                  [ CALL "*" | +rawCodeAddress ] emitLogic
                }

                { staticLoadPassivePattern callTargetMatch }' {
                  # nothing to emit
                }

                { 1 }' {
                  [ j j 16 add range peek each ] dump
                  o dump
                  j dump
                  "unparsed static load opcodes in sys .opt .hook (optimizing version)" die
                }
              ] conds
            }

            { customFunctionHeaderPattern callTargetMatch }' {
              [ CALL calledAddress ] emitLogic
            }

            { 1 }' {
              [ j j 16 add range peek each ] dump
              o dump
              j dump
              "unparsed call target opcodes in sys .opt .hook (optimizing version)" die
            }
          ] conds
        }

        { 1 }' {
          [ i i 16 add range peek each ] dump
          o dump
          i dump
          "unparsed opcodes in sys .opt .hook (optimizing version)" die
        }
      ] conds
    } loop

    [ ] ==newOpcodes
    { newOpcodes -01 cat =newOpcodes }' /emitOpcodes deffst
    [ ] ==newReferences
    { newReferences [ -102 ] cat =newReferences }' /emitReference deffst

    # [ :ud2 ] emitOpcodes # enable for further development

    isScoping {
      # "scoping function" dump
      [
        8 /r15 :subqImm8Reg
        /r15 :popqMem
        8 /r15 :subqImm8Reg
        ::currentScope /rbx :movqImmReg
        /rbx /rsi :movqMemReg
        /rsi /r15 :movqRegMem
        8 /rdi :movqImmReg
        ::internalAllocateScope /rax :movqImmReg
        /rax :callqReg
        /rax /rbx :movqRegMem
      ] emitOpcodes
    }" {
      # "unscoping function" dump
      [
        8 /r15 :subqImm8Reg
        /r15 :popqMem
      ] emitOpcodes
    }" ? *

    newLogic
    testScopeModifications
    containsScopeModifications not |rewriteConstantPipe rep
    containsScopeModifications not |rewriteConstantEquals rep
    containsScopeModifications not |rewriteConstantDot rep
    rewriteStackOps
    { =*entry 0 entry ==action
      [
        { action PUSH streq }' {
          [
            1 entry /rax :movqImmReg
            /rax :pushqReg
          ] emitOpcodes

          1 entry emitReference
        }

        { action CALL streq }' {
          [
            1 entry /rax :movqImmReg
            /rax :callqReg
          ] emitOpcodes

          1 entry 16 sub emitReference
        }

        { action CALLSCOPED streq }' {
          [
            2 entry /rsi :movqImmReg
            8 /r15 :subqImm8Reg

            ::currentScope /rax :movqImmReg
            /rsi /rax :xchgqRegMem
            /rsi /r15 :movqRegMem
            1 entry /rdi :movqImmReg
            /rdi :callqReg

            /r15 /rsi :movqMemReg
            ::currentScope /rax :movqImmReg
            /rsi /rax :movqRegMem

            8 /r15 :addqImm8Reg
          ] emitOpcodes

          1 entry 16 sub emitReference
          2 entry emitReference
        }

        { action [ STATIC STATICTYPED ] streq any }' {
          [
            ::currentScope /rax :movqImmReg
            /rax /rax :movqMemReg
            2 entry { 16 /rax /rax :movqMemDisp8Reg } rep

            3 entry {
              24 /rax /rcx :movqMemDisp8Reg # load extension area pointer
              /rax /edx :movlMemReg # load scope length
              /rdx :negqReg # prepare for substraction # TODO the length calculation could be done beforehand
              1 entry 1 /rdx /rcx :pushqMemIndexScaleDisp32 # push loaded entry to stack
            } {
              1 entry /rax :pushqMemDisp32
            } ? *
          ] emitOpcodes
        }

        { action STATICWRITE streq }' {
          [
            ::currentScope /rax :movqImmReg
            /rax /rax :movqMemReg
            2 entry { 16 /rax /rax :movqMemDisp8Reg } rep

            3 entry {
              24 /rax /rcx :movqMemDisp8Reg # load extension area pointer
              /rax /edx :movlMemReg # load scope length
              /rdx :negqReg # prepare for substraction
              1 entry 1 /rdx /rcx :popqMemIndexScaleDisp32 # load entry from stack
            } {
              1 entry /rax :popqMemDisp32
            } ? *
          ] emitOpcodes
        }

        { action STATICDOT streq }' {
          [
            /rax :popqReg
            2 entry { 16 /rax /rax :movqMemDisp8Reg } rep

            3 entry {
              24 /rax /rcx :movqMemDisp8Reg # load extension area pointer
              /rax /edx :movlMemReg # load scope length
              /rdx :negqReg # prepare for substraction
              1 entry 1 /rdx /rcx :pushqMemIndexScaleDisp32 # push loaded entry to stack
            } {
              1 entry /rax :pushqMemDisp32
            } ? *
          ] emitOpcodes
        }

        { action NATIVE streq }' {
          1 entry emitOpcodes
        }

        { action NOP streq }' {
        }

        { 1 }' {
          entry dump
          "invalid intermediate code during optimize" die
        }
      ] conds
    } each

    isScoping {
      [
        /r15 /rcx :movqMemReg
        ::currentScope /rax :movqImmReg
        /rcx /rax :movqRegMem
        8 /r15 :addqImm8Reg
        /r15 :pushqMem
        8 /r15 :addqImm8Reg
        :retn
      ] emitOpcodes
    }' {
      [
        /r15 :pushqMem
        8 /r15 :addqImm8Reg
        :retn
      ] emitOpcodes
    }' ? *

    # "optimization finished" dump

    newReferences newOpcodes o ::replace
    1 executingScope # return something different from o to signal successful optimization
  } /optimize deffd

  0 ==recursionDepth

  {
    recursionDepth 1 add =recursionDepth
    recursionDepth 3 lt { optimize } { } ? *
    recursionDepth 1 sub =recursionDepth
  } /hook sys .opt .deff
> --

# vim: syn=elymas
