<
  4096 ==PAGESIZE
  4096 16 mul 8 mul ==STACKSIZE
  65536 ==GLOBALALLOCSSIZE
  128 ==STACKSTART

  # hex decoding
  {
    "(.)(.)" regex { } { "not a valid hex-string" die } ? *
    { { streq }_ [ "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ] -01 index }
    -20*10* 16 mul add
  } "%" defq

  "elymasAsmOps.ey" include

  # map "anonymous" allocations away from interpreter heap

  52776558133248 ==miscAllocBase # 0x300000000000
  { ==size
    size miscAllocBase sys .asm .allocAt
    size miscAllocBase add =miscAllocBase
  } /alloc deff

  # global alloc list layout
  # %0 : next unused byte of global alloc list as an offset from beginning of list
  # %8 : <unused>
  # %10 : base of this very alloc
  # %18 : size of this very alloc
  # %20... : <base> <size> of next allocs
  <
    { # ==addr
      [ -01 7 add 8 { _ sys .asm .peek -01 1 sub } rep -- ] { -01 256 mul add } fold
    } /peekImm64 deff

    { ==addr ==value
      [ value imm64 ] { addr sys .asm .poke addr 1 add =addr } each
    } /pokeImm64 deff

    GLOBALALLOCSSIZE alloc ==allocs
    allocs .base ==i
    [
      %20 imm64
      0 imm64
      allocs .base imm64
      allocs .size imm64
    ] { i sys .asm .poke i 1 add =i } each

    { ==block
      allocs .base peekImm64 ==nextOffset
      nextOffset 16 add _
        GLOBALALLOCSSIZE gt { "Global allocation list full." die } rep
        allocs .base pokeImm64
      allocs .base nextOffset add =nextOffset

      block .base nextOffset       pokeImm64
      block .size nextOffset 8 add pokeImm64
    } /register deff

    { allocs .base } /base deff
  > ==globalAllocations

  # global stack layout
  # 0 - STACKSTART  : global variables
  #              %0 : current stack pointer
  # STACKSTART - ...: real stack
  [ /mainStack /mainCallStack ] {
    <
      STACKSIZE alloc _ globalAllocations .register
                        ==stack
      stack .base ==i
      [
        stack .base STACKSIZE add imm64
      ] { i sys .asm .poke i 1 add =i } each

      stack
    > -12 ==
  }' each

  STACKSIZE alloc _ globalAllocations .register
                    .base ==:quoteEncodingBufferCode

  STACKSIZE alloc _ globalAllocations .register
                    .base ==:quoteEncodingBufferObjects

  { ==opcodes
    opcodes len 1 sub PAGESIZE div 1 add PAGESIZE mul alloc /codearea defv
    sys .asm .|poke =*poke
    codearea .base opcodes { -101 poke 1 add } each --
    codearea
  } /arrayToCode deff

  # take an array of instruction bytes and execute it on the given stack
  { ==callStack ==valueStack ==opcodes
    [
      /rbx pushqReg
      /rbp pushqReg
      /r12 pushqReg
      /r13 pushqReg
      /r14 pushqReg
      /r15 pushqReg
      valueStack /rbx movqImmReg
      /rsp /rbx xchgqRegMem
      callStack /rbx movqImmReg
      /r15 /rbx xchgqRegMem
      /r14 8 /rbx xchgqRegMemDisp8

      opcodes _ len dearray

      callStack /rbx movqImmReg
      /r15 /rbx xchgqRegMem
      /r14 8 /rbx xchgqRegMemDisp8
      valueStack /rbx movqImmReg
      /rsp /rbx xchgqRegMem
      /r15 popqReg
      /r14 popqReg
      /r13 popqReg
      /r12 popqReg
      /rbp popqReg
      /rbx popqReg
      retn
    ]
  } /compileOn deff

  {
    compileOn arrayToCode _ .base sys .asm .execute
                            .free
  } /executeOn deff

  { mainStack .base mainCallStack .base executeOn } /execute deff

  { mainStack .base mainCallStack .base compileOn } /compile deff
> /assembler defv

# vim: syn=elymas
