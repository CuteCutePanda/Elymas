<
  4096 ==PAGESIZE
  16777216 ==STACKSIZE
  128 ==STACKSTART

  # hex decoding
  {
    "(.)(.)" regex { } { "not a valid hex-string" die } ? *
    { { streq }_ [ "0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "A" "B" "C" "D" "E" "F" ] -01 index }
    -20*10* 16 mul add
  } "%" defq

  # registers
  { [ /rax /rcx /rdx /rbx /rsp /rbp /rsi /rdi /r8 /r9 /r10 /r11 /r12 /r13 /r14 /r15 ] streq any } /bit64 deff
  { [ /eax /ecx /edx /ebx /esp /ebp /esi /edi /r8d /r9d /r10d /r11d /r12d /r13d /r14d /r15d ] streq any } /bit32 deff
  { [ /ax /cx /dx /bx /sp /bp /si /di /r8w /r9w /r10w /r11w /r12w /r13w /r14w /r15w ] streq any } /bit16 deff
  { [ /al /cl /dl /bl /spl /ah /bpl /ch /sil /dh /dil /bh /r8b /r9b /r10b /r11b /r12b /r13b /r14b /r15b ] streq any } /bit8 deff
  
  { { streq any }_ ==reg
    [
      [ /zero /al /ax /eax /rax /none ]
      [ /one /cl /cx /ecx /rcx ]
      [ /two /dl /dx /edx /rdx ]
      [ /three /bl /bx /ebx /rbx ]
      [ /four /sib /spl /ah /sp /esp /rsp ]
      [ /five /bpl /ch /bp /ebp /rbp ]
      [ /six /sil /si /esi /rsi ]
      [ /seven /dil /di /edi /rdi ]
      [ /r8b /r8w /r8d /r8 ]
      [ /r9b /r9w /r9d /r9 ]
      [ /r10b /r10w /r10d /r10 ]
      [ /r11b /r11w /r11d /r11 ]
      [ /r12b /r12w /r12d /r12 ]
      [ /r13b /r13w /r13d /r13 ]
      [ /r14b /r14w /r14d /r14 ]
      [ /r15b /r15w /r15d /r15 ]
    ] reg index
    _ 1 neg gt assert
  } /regno deff

  # encoding a REX prefix
  { ==b ==x ==r ==w
                          %40
    w                0 gt %08 mul add
    r regno %08 band 0 gt %04 mul add
    x regno %08 band 0 gt %02 mul add
    b regno %08 band 0 gt %01 mul add
  } /rex deff

  { =mem =reg
    mem [ /spl /sp /esp /rsp /bpl /bp /ebp /rbp ] streq any not assert

                    %00
    mem regno       %07 band add
    reg regno 8 mul %38 band add
  } /modrm00 deff

  { =mem =reg
    mem [ /spl /sp /esp /rsp ] streq any not assert

                    %40
    mem regno       %07 band add
    reg regno 8 mul %38 band add
  } /modrm01 deff

  { =mem =reg
    mem [ /spl /sp /esp /rsp ] streq any not assert

                    %80
    mem regno       %07 band add
    reg regno 8 mul %38 band add
  } /modrm10 deff

  { =mem =reg
                    %C0
    mem regno       %07 band add
    reg regno 8 mul %38 band add
  } /modrm11 deff

  { ==base ==idx ==scale
    idx [ /spl /sp /esp /rsp ] streq any not assert
    base [ /bpl /bp /ebp /rbp ] streq any not assert
    scale _ 0 gt assert 8 le assert

    scale [ 1 %00 %40 1 %80 1 1 1 %C0 ] *
      _ 1 neq assert
    %C0 band
    %38 idx regno 8 mul band add
    %07 base regno band add
  } /sib deff

  { _ 0 ge assert 8 { _ 256 mod -01 256 div } rep -- } /imm64 deff
  { _ 0 ge assert 4 { _ 256 mod -01 256 div } rep -- } /imm32 deff
  { _ 0 ge assert 2 { _ 256 mod -01 256 div } rep -- } /imm16 deff
  { _ 0 lt { 256 add } rep 255 band } /imm8 deff

  # label handling
  < { defv }' /put deff > ==labels
  [ ] ==labelHoles

  { ==l
    ] _ len l labels .put [ -011 len dearray
  } /label deff

  { ==l
    ] _ len ==offset
    labelHoles [ {
      labels l . offset 1 add sub
      _ 128 lt assert
      _ 128 neg ge assert
      imm8 offset -102 =[] } ] cat =labelHoles
    [ -011 len dearray %00
  } /labelRel8 deff

  { ==opcodes
    labelHoles { opcodes -01 * } each

    < { defv }' /put deff > =labels
    [ ] =labelHoles

    opcodes
  } /labelResolve deff

  # instructions
  { ==reg ==mem
    reg bit32 assert
    mem bit64 assert

    reg regno %07 gt mem regno %07 gt or { 0 reg /none mem rex } rep
    %03
    reg mem modrm00
  } /addlMemReg deff

  { ==mem ==disp ==i
    mem bit64 assert
    i 256 lt assert

    1 /none /none mem rex
    %83
    /zero mem modrm01
    disp imm8
    i imm8
  } /addqImm8MemDisp8 deff

  { ==reg ==i
    reg bit64 assert
    i 256 lt assert

    1 /none /none reg rex
    %83
    /zero reg modrm11
    i imm8
  } /addqImm8Reg deff

  { ==reg ==mem ==disp
    reg bit64 assert
    mem bit64 assert
    disp 128 lt assert

    1 reg /none mem rex
    %03
    reg mem modrm01
    disp imm8
  } /addqMemDisp8Reg deff

  { ==dst ==src
    dst bit64 assert
    src bit64 assert

    1 src /none dst rex
    %01
    src dst modrm11
  } /addqRegReg deff

  { ==reg
    reg bit64 assert

    reg regno %07 gt { 1 /none /none reg rex } rep
    %FF
    /two reg modrm11
  } /callqReg deff

  {
    %A6
  } /cmpsb deff

  {
    1 /none /none /none rex
    %A7
  } /cmpsq deff

  { ==mem ==reg
    reg bit32 assert
    mem bit64 assert

    reg regno %07 gt mem regno %07 gt or { 0 reg /none mem rex } rep
    %39
    reg mem modrm00
  } /cmplRegMem deff

  { ==mem ==reg
    reg bit64 assert
    mem bit64 assert

    1 reg /none mem rex
    %39
    reg mem modrm00
  } /cmpqRegMem deff

  { ==dst ==src
    dst bit64 assert
    src bit64 assert

    1 src /none dst rex
    %39
    src dst modrm11
  } /cmpqRegReg deff

  { ==reg
    reg bit64 assert

    1 /none /none reg rex
    %FF
    /zero reg modrm11
  } /incqReg deff

  { < ==name ==opcode
    { ==offset
      offset 128 neg ge assert
      offset 128 lt assert

      opcode
      offset imm8
    } name "Rel8" cat

    { ==lbl

      opcode
      lbl labelRel8
      _ 128 neg ge assert
      _ 128 lt assert
    } name "Lbl8" cat
    > -- 2 |deff rep
  }' /defJmp deff

  %EB /jmp defJmp

  %72 /jb defJmp
  %76 /jbe defJmp
  %7E /jle defJmp
  %73 /jnb defJmp
  %75 /jnz defJmp
  %74 /jz defJmp

  { ==reg ==mem
    reg bit32 assert
    mem bit64 assert

    reg regno %07 gt mem regno %07 gt or { 0 reg /none mem rex } rep
    %8B
    reg mem modrm00
  } /movlMemReg deff

  { ==reg ==i
    reg bit64 assert

    1 /none /none reg rex
    %B8 reg regno %07 band add
    i imm64
  } /movqImmReg deff

  { ==mem ==disp ==i
    mem bit64 assert
    i 2147483648 lt assert
    i 2147483648 neg ge assert

    1 /none /none mem rex
    %C7
    /zero mem modrm01
    disp imm8
    i imm32
  } /movqImm32MemDisp8 deff

  { ==reg
    reg bit64 assert

    1 /none /none reg rex
    %B8 reg regno %07 band add
  } /movqImmOOBReg deff

  { ==reg ==mem ==disp
    reg bit64 assert
    mem bit64 assert
    disp 128 lt assert

    1 reg /none mem rex
    %8B
    reg mem modrm01
    disp imm8
  } /movqMemDisp8Reg deff

  { ==reg ==mem ==idx
    reg bit64 assert
    mem bit64 assert
    idx bit64 assert

    1 reg idx mem rex
    %8B
    reg /sib modrm00
    1 idx mem sib
  } /movqMemIndexReg deff

  { ==reg ==mem
    reg bit64 assert
    mem bit64 assert

    1 reg /none mem rex
    %8B
    reg mem modrm00
  } /movqMemReg deff

  { ==mem ==reg
    reg bit64 assert
    mem bit64 assert

    1 reg /none mem rex
    %89
    reg mem modrm00
  } /movqRegMem deff

  { ==mem ==disp ==reg
    reg bit64 assert
    mem bit64 assert
    disp 128 lt assert

    1 reg /none mem rex
    %89
    reg mem modrm01
    disp imm8
  } /movqRegMemDisp8 deff
  
  { ==mem ==idx ==reg
    reg bit64 assert
    mem bit64 assert
    idx bit64 assert

    1 reg idx mem rex
    %89
    reg /sib modrm00
    1 idx mem sib
  } /movqRegMemIndex deff

  { ==dst ==src
    src bit64 assert
    dst bit64 assert

    1 src /none dst rex
    %89
    src dst modrm11
  } /movqRegReg deff

  { ==mem ==i
    mem bit64 assert
    i 256 lt assert

    %80
    /one mem modrm00
    i imm8
  } /orbImmMem deff

  { ==mem ==disp ==i
    mem bit64 assert
    i 256 lt assert
    disp 128 lt assert

    %80
    /one mem modrm01
    disp imm8
    i imm8
  } /orbImmMemDisp8 deff

  { ==reg
    reg regno %07 gt { 1 /none /none reg rex } rep
    %58 reg regno %07 band add
  } /popqReg deff

  { ==reg
    reg regno %07 gt { 1 /none /none reg rex } rep
    %50 reg regno %07 band add
  } /pushqReg deff

  { ==imm
    %68
    imm imm32
  } /pushqImm32 deff

  {
    %F3
  } /repz deff

  {
    %C3
  } /retn deff

  { ==reg ==i
    reg bit64 assert
    i 64 lt assert

    1 /none /none reg rex
    %C1
    /four reg modrm11
    i imm8
  } /shlqImm8Reg deff

  { ==reg
    reg bit64 assert

    1 /none /none reg rex
    %D1
    /five reg modrm11
  } /shrq1Reg deff

  { ==reg ==i
    reg bit64 assert
    i 256 lt assert

    1 /none /none reg rex
    %83
    /five reg modrm11
    i imm8
  } /subqImm8Reg deff

  { ==reg ==mem ==disp
    reg bit64 assert
    mem bit64 assert
    disp 128 lt assert

    1 reg /none mem rex
    %2B
    reg mem modrm01
    disp imm8
  } /subqMemDisp8Reg deff

  { ==reg ==mem
    reg bit32 assert
    mem bit64 assert

    reg regno %07 gt mem regno %07 gt or { 0 reg /none mem rex } rep
    %2B
    reg mem modrm00
  } /sublMemReg deff

  { ==reg ==mem
    reg bit64 assert
    mem bit64 assert

    1 reg /none mem rex
    %2B
    reg mem modrm00
  } /subqMemReg deff

  { ==dst ==src
    dst bit64 assert
    src bit64 assert

    1 src /none dst rex
    %29
    src dst modrm11
  } /subqRegReg deff

  {
    %0F %05
  } /syscall deff

  { ==dst ==src
    dst bit64 assert
    src bit64 assert

    1 src /none dst rex
    %85
    src dst modrm11
  } /testqRegReg deff

  {
    %0F
    %0B
  } /ud2 deff

  { ==mem ==reg
    reg bit64 assert
    mem bit64 assert

    1 reg /none mem rex
    %87
    reg mem modrm00
  } /xchgqRegMem deff

  { ==dst ==src
    dst bit64 assert
    src bit64 assert

    1 src /none dst rex
    %87
    src dst modrm11
  } /xchgqRegReg deff

  { ==reg ==mem
    reg bit64 assert
    mem bit64 assert

    1 reg /none mem rex
    %33
    reg mem modrm00
  } /xorqMemReg deff

  { ==mem ==reg
    reg bit64 assert
    mem bit64 assert

    1 reg /none mem rex
    %31
    reg mem modrm00
  } /xorqRegMem deff

  { ==dst ==src
    dst bit64 assert
    src bit64 assert

    1 src /none dst rex
    %31
    src dst modrm11
  } /xorqRegReg deff

  # global stack layout
  # 0 - STACKSTART  : global variables
  #              %0 : current stack pointer
  # STACKSTART - ...: real stack
  STACKSIZE sys .asm .alloc ==mainStack
  <
    mainStack .base ==i
    [
      mainStack .base STACKSIZE add imm64
    ] { i sys .asm .poke i 1 add =i } each
  > --

  { ==opcodes
    opcodes len 1 sub PAGESIZE div 1 add PAGESIZE mul sys .asm .alloc /codearea defv
    codearea .base ==i
    opcodes { i sys .asm .poke i 1 add =i } each
    codearea
  } /arrayToCode deff

  # take an array of instruction bytes and execute it on the given stack
  { ==stack ==opcodes
    [
      /rbx pushqReg
      stack /rbx movqImmReg
      /rsp /rbx xchgqRegMem
    ] opcodes [
      stack /rbx movqImmReg
      /rsp /rbx xchgqRegMem
      /rbx popqReg
      retn
    ] cat cat =opcodes

    opcodes arrayToCode _ .base sys .asm .execute
                          .free
  } /executeOn deff

  { mainStack .base executeOn } /execute deff
> /assembler defv

# vim: syn=elymas
