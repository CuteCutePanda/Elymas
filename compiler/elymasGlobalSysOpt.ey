<
  "opt" enterSubScope

  <
    # stub
    # 0 -> code object
    # 1 -> current scope
    # 0 <- same code object (if different object, optimization would have taken place)
    # 1 <- current scope (value ignored)
    [[
      :retn
    ]] /eyhook defv

    # replace code block by better code
    # 0 -> code block to replate (and patch)
    # 1 -> new opcodes as integer array
    # 2 -> new references as array
    [[
      32 /r15 :subqImm8Reg
      24 /r15 :popqMemDisp8 # store return address
      16 /r15 :popqMemDisp8 # code block to patch
      8 /r15 :popqMemDisp8 # new opcode source
      /r15 :popqMem # new references source

      # copy new opcodes
      :quoteEncodingBufferCode /rdi :movqImmReg
      
      8 /r15 /rsi :movqMemDisp8Reg
      /rsi /ecx :movlMemReg
      8 /rsi :addqImm8Reg
      3 /rcx :shrqImm8Reg
      /rcx :decqReg
      /noOpcodesToCopy :jzLbl8

      @opcodeCopyLoop
      /rsi /rax :movqMemReg
      /rax ::unboxInteger
      :stosb
      8 /rsi :addqImm8Reg
      /opcodeCopyLoop :loopLbl8

      @noOpcodesToCopy
      /rdi /rbp :movqRegReg

      # copy new references
      :quoteEncodingBufferObjects /rdi :movqImmReg

      /r15 /rsi :movqMemReg
      /rsi /ecx :movlMemReg
      8 /rsi :addqImm8Reg
      3 /rcx :shrqImm8Reg
      /rcx :decqReg
      /noReferencesToCopy :jzLbl8

      @referencesCopyLoop
      /rsi /rax :movqMemReg
      8 /rax /rax :movqMemDisp8Reg
      :stosq
      8 /rsi :addqImm8Reg
      /referencesCopyLoop :loopLbl8

      @noReferencesToCopy
      /rbp /rdi :xchgqRegReg

      ::internalAllocateCodeFromEncodingBuffer /rax :movqImmReg
      /rax :callqReg

      # patch old code
      16 /r15 /rdi :movqMemDisp8Reg
      8 /rdi /rbp :movqMemDisp8Reg
      16 1 /rbp /rdi /rbp :leaqMemIndexScaleDisp8Reg

      # CHECK
      /rdi /ecx :movlMemReg
      /rdi /rcx :addqRegReg
      /rcx /rbp :cmpqRegReg
      /patchSpaceAvailable :jbLbl8

      "attepmting to patch reference, but no space is available" ::outputError
      :ud2

      @patchSpaceAvailable
      # END CHECK

      16 /rdi :addqImm8Reg

      [
        /rax :movqImmOOBReg
      ] ::loadToRdi
      16 /rax :addqImm8Reg
      /rax /rdi :movqRegMem
      16 /rax :subqImm8Reg
      /rax 0 /rbp :movqRegMemDisp8
      8 /rdi :addqImm8Reg
      8 /rbp :addqImm8Reg
      [
        /rax :jmpqReg
      ] ::loadToRdi

      # TODO old references still around (and possibly used by later code)

      24 /r15 :pushqMemDisp8
      32 /r15 :addqImm8Reg
      :retn
    ]] /eyreplace defv

    # returns internalAllocateInteger into userspace
    # 0 <- ::internalAllocateInteger as integer
    [[
      /rbx :popqReg

      ::internalAllocateInteger /rax :movqImmReg
      /rax :callqReg
      /rax :pushqReg

      ::internalAllocateInteger /rdx :movqImmReg
      /rdx 8 /rax :movqRegMemDisp8

      /rbx :pushqReg
      :retn
    ]] /eyinternalAllocateInteger defv

    # returns internalAllocateScope into userspace
    # 0 <- ::internalAllocateScope as integer
    [[
      /rbx :popqReg

      ::internalAllocateInteger /rax :movqImmReg
      /rax :callqReg
      /rax :pushqReg

      ::internalAllocateScope /rdx :movqImmReg
      /rdx 8 /rax :movqRegMemDisp8

      /rbx :pushqReg
      :retn
    ]] /eyinternalAllocateScope defv
  > _ ==globalFunctions { defv }' ::allocateOffsetStruct

  [
    globalFunctions keys eydeff { | }' createScopeEntries
    createScopeExtensionEntries
  ] :execute

  leaveSubScope
> --

# vim: syn=elymas
