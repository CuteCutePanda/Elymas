|defv "==" deff
|deff "=*" deff

{ "}" | *
  { /f deff /x defv
    { x f }
  } quoted { } { * } ? *
} "}_" defq

{ deff }' " globalDeff" deff # this is not for public usage
{
  { -01 < /o defv { o -01 . } > -12 } quoted { } { * } ? *
  quoted { |deff } " globalDeff" | ? *
} /via defq

{ -1110 ; ==f =*a len _
  {
    0 a
    1 -102 range f each
    }' { "fold on empty array" die }'
  ? *
} /fold deff

{ _ =*a len
  [ 1 -1202 1 add range { -110 sub a -01 }' each -- ] # TODO: rethink this one, seems overly complicated
} /reverse deff

{ |or fold } /any deff
{ |and fold } /all deff

{ =*p {
  [ -01 { _ p { } { -- } ? * } each ]
} } /engrep deff

{ engrep * } /grep deff
{ -110 ; engrep |dom -20*1* } /indices deff

{ =*p _ =*a len ==l
  1 neg ==r

  0 {
    _ l lt 1 neg r eq and
  } {
    _ a p { _ =r } { } ? *
      1 add
  } loop --
  r
} /index deff

{
  not { "Assertion failure" die } rep
} /assert deff

{ ==s
  [ s keys { s -01 . } each ]
} /values deff

{ _ =*conds len ==max
  0 ==i { i max lt } {
    i conds { i 1 add conds * max =i } { } ? *
    i 2 add =i
  } loop
} /conds deff

# vim: syn=elymas
