"elymasAsm.ey" include

<
  { assembler -01 . } ":" deff
  assembler .|label "@" deff
  "%" _ : -01 deff

  <
    1 ==PROT_READ
    2 ==PROT_WRITE
    4 ==PROT_EXEC

    2 ==MAP_PRIVATE
    16 ==MAP_FIXED
    32 ==MAP_ANONYMOUS
  > ==MMAP

  <
    9 ==mmap
  > ==SYSCALL

  { =*def ==struct
    struct values |cat fold :arrayToCode .base ==address
    struct keys { address -101 def struct -01 . len address add =address } each
  } /allocateOffsetStruct deff

  <
    # current end of heap memory (grows upwards)
    [ %00 %00 %00 %00 %00 %60 %00 %00 ] ==heapEnd

    # next free byte at end of heap
    [ %00 %00 %00 %00 %00 %60 %00 %00 ] ==unusedHeapStart
    
    # current parser scope
    [ %00 %00 %00 %00 %00 %00 %00 %00 ] ==currentScope

    # current parser quote state
    [ %00 %00 %00 %00 %00 %00 %00 %00 ] ==currentQuoted
  > { defv }' allocateOffsetStruct

  # internal functions, ABI follows SysV standards

  # compare two strings
  # rdi -> address of first string
  # rsi -> address of second string
  # rax <- 1 if both strings are equal, 0 otherwise
  [
    /rax /rax :xorqRegReg
    :cmpsq # ignore memory length header
    :cmpsq # ignore hash
    /rsi /rdx :movqMemReg # load exact length
    :cmpsq # same exact length
    /fail :jnzLbl8
    /rdx /rcx :movqRegReg
    :repz :cmpsb
    /fail :jnzLbl8
    /rax :incqReg
    @fail
  ] :labelResolve /internalStringEqualsCode defv

  <
    # allocate a chunk of memory
    # rdi -> size of chunk in bytes
    # rax <- address of allocated chunk
    #        chunk will have GC length header initialized correctly
    # FIXME put a real allocator here
    [
      /rbx :pushqReg
      /rdi :pushqReg
      unusedHeapStart /rax :movqImmReg
      /rax /rcx :movqMemReg
      /rcx /rbx :movqRegReg
      /rcx /rdx :movqRegReg
      /rdi /rcx :addqRegReg
      /rcx /rax :movqRegMem
      heapEnd /rax :movqImmReg
      /rax /rdi :movqMemReg
      /rdi /rcx :cmpqRegReg
      [
        4096 4096 mul /rsi :movqImmReg
        /rsi /rdi :addqRegReg
        /rdi /rax :movqRegMem
        /rsi /rdi :subqRegReg

        SYSCALL .mmap /rax :movqImmReg
        # /rdi already fine
        # /rsi already fine
        < { MMAP -01 . } "!" deff
          !PROT_READ !PROT_WRITE !PROT_EXEC bor bor /rdx :movqImmReg
          !MAP_PRIVATE !MAP_FIXED !MAP_ANONYMOUS bor bor /r10 :movqImmReg
        > --
        /r8 :movqImmOOBReg %FF %FF %FF %FF %FF %FF %FF %FF
        0 /r9 :movqImmReg
        :syscall
      ] |len { :jbeRel8 } -21*0*221* dearray
      /rbx /rax :movqRegReg
      /rdi :popqReg
      /rdi /rax :movqRegMem
      /rbx :popqReg
      :retn
    ] /internalAllocate defv

    # compare two strings
    # rdi -> address of first string
    # rsi -> address of second string
    # rax <- 1 if both strings are equal, 0 otherwise
    [
      internalStringEqualsCode _ len dearray
      :retn
    ] /internalStringEquals defv

    # resolve element from scope
    # rdi -> address of scope on the heap
    # rsi -> address of element name on the heap
    # rax <- address of element on the heap (0 if nonexistant)
    # rdx <- 0 if element is passive
    #        1 if element is active
    #        2 if element is quote-active
    [
      8 /rdi /rcx :movqMemDisp8Reg # load name table
      /rcx /rdx :movqRegReg
      16 /rdx :addqImm8Reg # rdx will iterate over entries
      8 /rcx /rcx :addqMemDisp8Reg # compute name table effective end

      @loop
      /rdx /rcx :cmpqRegReg
      /end :jbeLbl8
      # TODO this is ridiculous
      /rdi :pushqReg
      /rsi :pushqReg
      /rdx :pushqReg
      /rcx :pushqReg
      /rdx /rdi :movqMemReg
      internalStringEqualsCode _ len dearray
      /rcx :popqReg
      /rdx :popqReg
      /rsi :popqReg
      /rdi :popqReg

      /rax /rax :testqRegReg
      /found :jnzLbl8

      16 /rdx :addqImm8Reg
      /loop :jmpLbl8
      @end

      # not found at all, retry with parent
      # FIXME: Actually try with parent
      /rax /rax :xorqRegReg
      /rdx /rdx :xorqRegReg
      :retn

      @found
      8 /rdx /rax :movqMemDisp8Reg # load default activation
      8 /rdi /rdx :subqMemDisp8Reg # substract name table start
      16 /rdx :subqImm8Reg # substract name table header size
      /rdx :shrq1Reg # divide by 2 to get offset within scope

      # rdx == entry index * 8 in scope
      # rax == entry default activation

      32 /rdx :addqImm8Reg # add scope header size
      /edx /rdi :cmplRegMem # TODO this fails for > 4 GB scopes
      /inDataArea :jnbLbl8

      /rdi /edx :sublMemReg # substract scope length
      24 /rdi /rdi :movqMemDisp8Reg # load extension area pointer
      8 /rdx :addqImm8Reg # add extension area header length

      @inDataArea
      /rdx /rdi /rdx :movqMemIndexReg # load entry pointer
      /rax /rdx :xchgqRegReg
      :retn
    ] :labelResolve /internalResolve defv
  > { defv }' allocateOffsetStruct

  # TODO: link internal functions statically with relative calls
  <
    # allocate scope, expecting rdi entries
    # rdi -> expected number of entries
    # rsi -> parent scope
    # rax <- address of scope on the heap
    [
      /rdi :pushqReg
      
      # allocate name table
      4 /rdi :shlqImm8Reg
      16 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %30 7 /rax :orbImmMemDisp8

      # set fill to header size
      16 8 /rax :movqImm32MemDisp8

      /rdi :popqReg
      /rax :pushqReg # save name table on the stack

      3 /rdi :shlqImm8Reg
      32 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type and existence of all pointers
      %26 7 /rax :orbImmMemDisp8
      # reference name table
      /rcx :popqReg
      /rcx 8 /rax :movqRegMemDisp8
      # zero parent and extension
      /rdi /rdi :xorqRegReg
      /rdi 16 /rax :movqRegMemDisp8
      /rdi 24 /rax :movqRegMemDisp8

      :retn
    ] /internalAllocateScope defv

    # allocate function
    # rdi -> code pointer
    # rsi -> scope pointer
    # rdx -> type pointer
    # rax <- address of function on the heap
    [
      /rdi :pushqReg
      /rdx :pushqReg

      32 /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %50 7 /rax :orbImmMemDisp8

      /rsi 8 /rax :movqRegMemDisp8
      /rdx :popqReg
      /rdx 16 /rax :movqRegMemDisp8
      /rdi :popqReg
      /rdi 24 /rax :movqRegMemDisp8

      :retn
    ] /internalAllocateFunction defv

    # allocate code block
    # rdi -> number of code bytes
    # rax <- address of code block on heap
    [
      8 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %60 7 /rax :orbImmMemDisp8
      :retn
    ] /internalAllocateCode defv

    # allocate array, expecting rdi/8 entries
    # rdi -> expected number of entry bytes
    # rax <- address of array on the heap
    [
      8 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %70 7 /rax :orbImmMemDisp8

      :retn
    ] /internalAllocateArray defv
  > { defv }' allocateOffsetStruct

  # elymas functions, stack based ABI

  1 ==ARRAYMARKER
  2 ==QUOTEMARKER

  # 0 -> integer
  # 1 -> integer
  # 0 <- result of the arithmetic operation
  { ==opcodes
    [
      /rbx :popqReg

      # allocate result int
      16 /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # type zero does not need to be changed

      # actual calculation
      /rcx :popqReg
      8 /rcx /rcx :movqMemDisp8Reg

      /rdx :popqReg
      8 /rdx /rdx :movqMemDisp8Reg

      opcodes _ len dearray
      /rdx 8 /rax :movqRegMemDisp8

      # push int address on program stack
      /rax :pushqReg
      /rbx :pushqReg
      :retn
    ]
  } /makeArith deff

  <
    # do nothing
    [
      :retn
    ] /ey/ defv

    # resolve in scope but never execute
    [
      /rcx :popqReg
      /rax :popqReg
      /rcx :pushqReg
      /rax :pushqReg

      # scope resolution
      currentScope /rdi :movqImmReg
      /rdi /rdi :movqMemReg
      /rsi :popqReg
      internalResolve /rax :movqImmReg
      /rax :callqReg

      /rcx :popqReg
      /rax :pushqReg
      /rcx :pushqReg
      :retn
    ] /ey| defv

    # arithmetic functions on ints
    [ /rcx /rdx :addqRegReg ] makeArith /eyadd defv
    [ /rcx /rdx :subqRegReg ] makeArith /eysub defv
    [ /rcx /rdx :andqRegReg ] makeArith /eyband defv
    [ /rcx /rdx :orqRegReg ] makeArith /eybor defv
    [ /rcx /rdx :xorqRegReg ] makeArith /eybxor defv

    { ==activation
      # create a new entry in the current scope for the given name
      # mark that entry's default action according to activation
      # 0 -> name, string
      # 1 -> object
      [
        /rcx :popqReg
        /rdi :popqReg

        # search for name in nametable
        currentScope /rax :movqImmReg
        /rax /rbx :movqMemReg # rbx == start of scope in heap
        8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
        8 /rbx /rsi :movqMemDisp8Reg # rsi == start of nametable in heap
        8 /rsi /rsi :addqMemDisp8Reg # rsi == end of nametable in heap (according to fill)

        @nameSearch
        16 /rdx :addqImm8Reg

        # rsi: end of nametable
        # rdx: current element of nametable

        /rdx /rsi :cmpqRegReg
        /nameUndefined :jbeLbl8

        /rdx :pushqReg
        /rsi :pushqReg
        /rdi :pushqReg
        /rcx :pushqReg
        /rdx /rsi :movqMemReg
        internalStringEqualsCode _ len dearray
        /rcx :popqReg
        /rdi :popqReg
        /rsi :popqReg
        /rdx :popqReg
        /rax /rax :testqRegReg
        /nameOffsetKnown :jnzLbl8

        # if not exists, insert
        @nameUndefined
        8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
        /rdx /eax :movlMemReg # add memory length to obtain memory end
        /rax /rdx :addqRegReg

        /rsi /rdx :cmpqRegReg
        /enlargeNameTable :jbeLbl8

        # insert into name table
        /rdi /rsi :movqRegMem
        activation 8 /rsi :movqImm32MemDisp8 # set default activation mode
        8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
        16 8 /rdx :addqImm8MemDisp8 # increment fill
        /rsi /rdx :movqRegReg
        /nameOffsetKnown :jmpLbl8

        @enlargeNameTable
        # if name table is already full, double size
        # FIXME
        :ud2
        
        @nameOffsetKnown
        8 /rbx /rdx :subqMemDisp8Reg # substract name table address
        16 /rdx :subqImm8Reg # substract name table header size
        /rdx :shrq1Reg # divide by 2 to get offset within scope

        # rdx == offset in scope
        # top of stack: the object to store

        # update 
        # if fits within main area, fine
        32 /rdx :addqImm8Reg # add scope header size
        /edx /rbx :cmplRegMem # TODO this fails for > 4 GB scopes
        /inDataArea :jnbLbl8

        # update within extension area
        /rbx /edx :sublMemReg # substract scope length
        24 /rbx /rbx :movqMemDisp8Reg # load extension area pointer
        8 /rdx :addqImm8Reg # add extension area header length

        # if extension area is full, double size
        /edx /rbx :cmplRegMem
        /inExtensionArea :jnbLbl8

        # FIXME
        :ud2

        @inExtensionArea
        @inDataArea

        /rax :popqReg
        /rax /rbx /rdx :movqRegMemIndex # save entry pointer

        /rcx :pushqReg
        :retn
      ] :labelResolve
    } 0 -101* /eydefv defv
      1 -101* /eydeff defv
      2  -01* /eydefq defv

    # execute top stack element
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      /rdx :popqReg

      # enter scope
      8 /rdx /rcx :movqMemDisp8Reg
      /rcx /rcx :testqRegReg
      /scoped :jnzLbl8
      currentScope /rax :movqImmReg
      /rax /rcx :movqMemReg
      @scoped
      8 /r15 :subqImm8Reg
      /rcx /r15 :movqRegMem

      # handle typed function
      16 /rdx /rcx :movqMemDisp8Reg
      /rcx /rcx :testqRegReg
      /typed :jnzLbl8

      24 /rdx /rax :movqMemDisp8Reg
      8 /rax :addqImm8Reg
      /rax :callqReg
      /done :jmpLbl8

      @typed
      :ud2 # TODO handle typed functions and autolooping

      @done
      /r15 /rcx :movqMemReg
      currentScope /rax :movqImmReg
      /rcx /rax :movqRegMem
      8 /r15 :addqImm8Reg
      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /ey* defv

    # dump top stack element (actually drop it for now)
    # FIXME: this belongs in the standard library
    [
      /rax :popqReg
      /rcx :popqReg
      /rax :pushqReg
      :retn
    ] /eydump defv

    # array construction, push begin marker on stack
    [
      /rax :popqReg
      ARRAYMARKER :pushqImm32
      /rax :pushqReg
      :retn
    ] /ey[ defv

    # array construction, create array from begin marker onwards
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      ARRAYMARKER /rax :movqImmReg
      /rsp /rdi :movqRegReg
      8 /rdi :subqImm8Reg
      @search
      8 /rdi :addqImm8Reg
      /rdi /rax :cmpqMemReg
      /search :jneLbl8

      /rdi /rcx :movqRegReg
      /rsp /rdi :subqRegReg
      /rcx :pushqReg

      # rdi == size of array
      internalAllocateArray /rax :movqImmReg
      /rax :callqReg
       
      /rdi :popqReg
      /rax /rdi :movqRegMem # store array pointer instead of begin marker

      /rax /ecx :movlMemReg
      3 /rcx :shrqImm8Reg
      /rcx :decqReg

      8 /rax :addqImm8Reg
      @copy
      /rax :popqMem
      /copy :loopLbl8

      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /ey] defv
  > _ ==globalFunctions { defv }' allocateOffsetStruct

  <
    # drop top stack element
    [
      /rax :popqReg
      /rcx :popqReg
      /rax :pushqReg
      :retn
    ] /ey-- defv

    # top stack element is a string defining a stack shuffle
    # 0-9: push the thusly numbered element
    #   *: execute top element
    # pops as many elements as the highest number specifies
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem
      80 /r15 :subqImm8Reg

      /rdi :popqReg
      16 /rdi /rcx :movqMemDisp8Reg # load string length
      24 /rdi /rax :leaqMemDisp8Reg # rax to begin of string

      42 /rsi :movqImmReg # initialize with '*'

      # find maximal element, note that '*' < '0'
      @maximalElementSearch
      /rax /rdx :movzxMem8Reg64
      /rsi /rdx :cmpqRegReg
      /rdx /rsi :cmovaqRegReg
      /rax :incqReg
      /maximalElementSearch :loopLbl8

      # move elements to temporary storage
      42 /rsi :cmpqImm8Reg
      /elementsSaved :jeLbl8
      
      47 /rsi :subqImm8Reg # substract '0'-1
      /rsi /rcx :movqRegReg
      /rsi /rsi :xorqRegReg

      @saveElements
      8 /rsi /r15 :popqMemIndexScale
      /rsi :incqReg
      /saveElements :loopLbl8

      # execute shuffle specification
      @elementsSaved
      16 /rdi /rcx :movqMemDisp8Reg # load string length
      24 /rdi /rax :leaqMemDisp8Reg # rax to begin of string

      @executeSpec
      /rax /rdx :movzxMem8Reg64
      /rax :incqReg

      42 /rdx :cmpqImm8Reg
      /executeTop :jeLbl8

      48 /rdx :subqImm8Reg # substract '0'
      8 /rdx /r15 :pushqMemIndexScale
      /executeSpec :loopLbl8
      /done :jmpLbl8

      @executeTop
      24 /r15 :subqImm8Reg
      /rax 16 /r15 :movqRegMemDisp8
      /rcx 8 /r15 :movqRegMemDisp8
      /rdx /r15 :movqRegMem
      |ey* /rax :movqImmReg
      /rax :callqReg
      /r15 /rdx :movqMemReg
      8 /r15 /rcx :movqMemDisp8Reg
      16 /r15 /rax :movqMemDisp8Reg
      24 /r15 :addqImm8Reg
      /executeSpec :loopLbl8

      @done
      80 /r15 :addqImm8Reg
      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /ey- defv

    # execute top stack element multiple times
    # 0 -> function to execute
    # 1 -> how often to execute it
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      8 /r15 :subqImm8Reg
      /r15 :popqMem # store function to call

      8 /r15 :subqImm8Reg
      /rcx :popqReg
      8 /rcx /rcx :movqMemDisp8Reg

      @loop
      /rcx /r15 :movqRegMem
      
      8 /r15 :pushqMemDisp8
      |ey* /rax :movqImmReg
      /rax :callqReg

      /r15 /rcx :movqMemReg
      /loop :loopLbl8
      
      16 /r15 :addqImm8Reg

      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /eyrep defv
  > _ ==globalFunctions2 { defv }' allocateOffsetStruct

  <
    # quote construction, push begin marker on stack
    [
      /rax :popqReg
      QUOTEMARKER :pushqImm32
      currentQuoted /rcx :movqImmReg
      /rcx :incqMem
      /rax :pushqReg
      :retn
    ] /ey{ defv

    <
      # FIXME: open a new function scope
      [
        8 /r15 :subqImm8Reg
        /r15 :popqMem
        8 /r15 :subqImm8Reg
        currentScope /rax :movqImmReg
        /rax /rax :movqMemReg
        /rax /r15 :movqRegMem
      ] /functionHeader defv

      [
        /r15 /rcx :movqMemReg
        currentScope /rax :movqImmReg
        /rcx /rax :movqRegMem
        8 /r15 :addqImm8Reg
        /r15 :pushqMem
        8 /r15 :addqImm8Reg
        :retn
      ] /functionFooter defv

      { _ =*array len _ 4 div ==largeMoves
                        4 mod ==smallMoves
        0 ==i
        largeMoves {
          i _ 4 add =i
              [ 3 2 1 0 ] add array { -01 256 mul add } fold /rdi :movlImmMem
          4 /rdi :addqImm8Reg
        } rep
        smallMoves {
          i _ 1 add =i
              array /rdi :movbImmMem
          /rdi :incqReg
        } rep
      } /loadToRdi deff

      # quote construction, create function from begin marker onwards
      [
        8 /r15 :subqImm8Reg
        /r15 :popqMem

        currentQuoted /rcx :movqImmReg
        /rcx :decqMem

        QUOTEMARKER /rcx :movqImmReg
        /rcx :pushqReg
        /rsp /rdx :movqRegReg
        @backwardsSearch
        8 /rdx :addqImm8Reg
        /rdx /rcx :cmpqMemReg
        /backwardsSearch :jneLbl8

        /rdx :pushqReg # store address of begin marker

        :quoteEncodingBuffer /rdi :movqImmReg

        functionHeader loadToRdi

        @search
        8 /rdx :subqImm8Reg
        /rdx /rcx :cmpqMemReg
        /markerFound :jeLbl8

        /rdx /rsi :movqMemReg
        7 /rsi /al :movbMemDisp8Reg
        %F0 /al :andbImmReg
        /immediateFound :jzLbl8
        %50 /al :cmpbImmReg
        /functionFound :jzLbl8
        %70 /al :cmpbImmReg
        /arrayFound :jzLbl8

        # TODO: "invalid object during quote construction"
        :ud2

        @immediateFound
        [ /rax :movqImmOOBReg ] _ len 2 eq assert
          2 dearray 256 mul add 
          /rdi :movwImmMem
        /rsi 2 /rdi :movqRegMemDisp8
        [ /rax :pushqReg ] _ len 1 eq assert
          1 dearray
          10 /rdi :movbImmMemDisp8
        11 /rdi :addqImm8Reg
        /search :jmpLbl8

        @functionFound
        [ /rax :movqImmOOBReg ] _ len 2 eq assert
          2 dearray 256 mul add 
          /rdi :movwImmMem
        /rsi 2 /rdi :movqRegMemDisp8
        [ /rax :pushqReg ] _ len 1 eq assert
          1 dearray
          10 /rdi :movbImmMemDisp8
        11 /rdi :addqImm8Reg
        [
          |ey* /rax :movqImmReg
          /rax :callqReg
        ] loadToRdi
        /search :jmpLbl8

        @arrayFound
        # FIXME allow macros to put byte arrays into quoted contexts and thereby generate assembly
        :ud2
        /search :jmpLbl8

        @markerFound

        functionFooter loadToRdi

        :quoteEncodingBuffer /rax :movqImmReg
        /rax /rdi :subqRegReg
        /rdi :pushqReg # store opcode byte count

        /rdi :decqReg
        3 /rdi :shrqImm8Reg
        /rdi :incqReg
        3 /rdi :shlqImm8Reg
        internalAllocateCode /rax :movqImmReg
        /rax :callqReg

        # rax == code block on heap

        # copy opcodes
        :quoteEncodingBuffer /rsi :movqImmReg
        8 /rax /rdi :leaqMemDisp8Reg
        /rcx :popqReg
        :reprcx :movsb

        # create function object
        /rax /rdi :movqRegReg
        currentScope /rax :movqImmReg
        /rax /rsi :movqMemReg
        /rdx /rdx :xorqRegReg
        internalAllocateFunction /rax :movqImmReg
        /rax :callqReg

        # rax == function object on heap

        # store function instead of begin marker
        /rdx :popqReg
        /rax /rdx :movqRegMem
        /rdx /rsp :movqRegReg # and drop quoted stuff from stack

        currentQuoted /rcx :movqImmReg
        /rcx /rcx :movqMemReg
        /rcx /rcx :testqRegReg
        /unquoted :jzLbl8

        :ud2
        # FIXME: quote once more

        @unquoted
        /r15 :pushqMem
        8 /r15 :addqImm8Reg
        :retn
      ] :labelResolve
    > -- /ey} defv
  > _ ==globalMacros { defv }' allocateOffsetStruct

  { strToUTF8Bytes _ =*v len _ ==exactLength
    1 sub 8 div 4 add 8 mul ==memoryLength

    memoryLength 2147483648 lt assert

    [
      # allocate string
      memoryLength /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # push string address on program stack
      /rax :pushqReg

      # set type
      7 /rax :addqImm8Reg
      %10 /rax :orbImmMem

      # clear hash value
      1 /rax :addqImm8Reg
      /rdx /rdx :xorqRegReg
      /rdx /rax :movqRegMem 

      # load exact length
      8 /rax :addqImm8Reg
      exactLength /rdx :movqImmReg
      /rdx /rax :movqRegMem 

      # load string contents
      0 exactLength 8 div range { 8 mul ==i
        8 /rax :addqImm8Reg
        /rdx :movqImmOOBReg i _ 7 add range v 8 dearray
        /rdx /rax :movqRegMem
      } each
    ]
  } /constStringCode deff

  [
    globalFunctions keys len globalFunctions2 keys len globalMacros keys len add add /rdi :movqImmReg
    internalAllocateScope /rax :movqImmReg
    /rax :callqReg

    currentScope /rdi :movqImmReg
    /rax /rdi :movqRegMem

    { ==createScopeEntry
      { ==name
        # create function
        name | 8 sub /rdi :movqImmReg
        currentScope /rsi :movqImmReg
        /rsi /rsi :movqMemReg
        # TODO: put a type here where applicable
        /rdx /rdx :xorqRegReg

        internalAllocateFunction /rax :movqImmReg
        /rax :callqReg
        /rax :pushqReg

        # create string
        name "ey(.*)" regex assert constStringCode _ len dearray

        # enter into current (i.e. global) scope
        createScopeEntry /rax :movqImmReg
        /rax :callqReg
      } each
    } /createScopeEntries deff
    globalFunctions keys eydeff createScopeEntries
    globalFunctions2 keys eydeff createScopeEntries
    globalMacros keys eydefq createScopeEntries
  ] :execute

  <
    [
      32 { "." } rep
      " " "!" "\"" "#" "$" "%" "&" "´" "(" ")" "*" "+" "," "-" "." "/"
      /0 /1 /2 /3 /4 /5 /6 /7 /8 /9 ":" ";" "<" "=" ">" "?"
      "@" /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P
      /Q /R /S /T /U /V /W /X /Y /Z "[" "\\" "]" "^" "_"
      "`" /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p
      /q /r /s /t /u /v /w /x /y /z "{" "|" "}" "~" "."
      128 { "." } rep
    ] /ASCII defv

    { # ==addr
      [ -01 7 add 8 { _ sys .asm .peek -01 1 sub } rep -- ] { -01 256 mul add } fold
    } /peekImm64 deff

    { # ==addr
      [ -01 3 add 4 { _ sys .asm .peek -01 1 sub } rep -- ] { -01 256 mul add } fold
    } /peekImm32 deff

    { # ==addr
      sys .asm .peek
    } /peekImm8 deff

    [ /0 /1 /2 /3 /4 /5 /6 /7 /8 /9 /A /B /C /D /E /F ] ==base16singleDigits
    [ base16singleDigits { ==first base16singleDigits { first -01 cat } each } each ] ==base16digits

    {
      [ -01 8 { _ 256 mod -01 256 div } rep -- ]
      base16digits *
      reverse |cat fold
    } /base16encode64 deff

    {
      [ -01 4 { _ 256 mod -01 256 div } rep -- ]
      base16digits *
      reverse |cat fold
    } /base16encode32 deff

    { ==objAddr
      "  int\n" sys .out .writestr
    } /intDump deff

    { ==objAddr
      "  \"" sys .out .writestr
      objAddr 16 add peekImm64 ==length
      objAddr 24 add _ length add 1 sub range peekImm8 ASCII * |cat fold sys .out .writestr
      "\"\n" sys .out .writestr
    } /stringDump deff

    { ==objAddr
      "  scope\n" sys .out .writestr

      objAddr       peekImm32
      objAddr 4 add peekImm32 16777215 band 4294967296 mul add ==length

      objAddr 8 add peekImm64 ==nameTable
      objAddr 16 add peekImm64 ==parent
      objAddr 24 add peekImm64 ==extensionArea

      nameTable 8 add peekImm64 ==nameTableEnd
      16 { _ nameTableEnd lt } {
        _ nameTable add base16encode64 ": " cat sys .out .writestr
        _ nameTable add peekImm64 stringDump
        _ 16 sub 2 div 32 add _ length lt { ==offset
            offset objAddr add peekImm64 memDump
          } {
            "Extension area dumping not yet implemented" die
          } ? *
        16 add
      } loop --
    } /scopeDump deff

    { ==objAddr
      "  nameTable\n" sys .out .writestr
    } /nameTableDump deff

    { ==objAddr
      "  extensionArea\n" sys .out .writestr
    } /extensionAreaDump deff

    { ==objAddr
      "  function\n" sys .out .writestr
    } /functionDump deff

    { ==objAddr
      "  code\n" sys .out .writestr
    } /codeDump deff

    { ==addr
      [
        "  "
        addr base16encode64
        ": "
        # the perl interpreter does not like full 64bit numbers and converts them into floats
        addr 4 add peekImm32 _ ==heapValueB base16encode32
        addr       peekImm32 _ ==heapValueA base16encode32
        " "
        [ [ heapValueA heapValueB ] { 4 { _ 256 mod -01 256 div } rep -- } each ] ASCII * 8 dearray
        "\n"
      ] |cat fold sys .out .writestr
    } /memDump deff

    { ==objAddr
      "Object at " objAddr base16encode64 cat " ----------\n" cat sys .out .writestr
      objAddr       peekImm32
      objAddr 4 add peekImm32 16777215 band 4294967296 mul
        add 8 div ==length
      0 length 1 sub range { 8 mul objAddr add memDump } each

      objAddr 7 add peekImm8 16 div
      [
        |intDump |stringDump |scopeDump |nameTableDump |extensionAreaDump |functionDump |codeDump |die
        |die |die |die |die |die |die |die |die
      ] *
      objAddr -01*
      "^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" sys .out .writestr
    } /heapDump deff

    {
      :mainStack .base :STACKSIZE add ==stackEnd
      "Stack ------------\n" sys .out .writestr
      :mainStack .base peekImm64 ==addr
      addr stackEnd gt { [ -01 stackEnd ] die } rep # Stack corrupted

      { addr stackEnd lt } {
        [
          addr base16encode64 ": "
          addr peekImm64 ==value
          value base16encode64
          "\n"
        ] |cat fold sys .out .writestr

        value 105553116266496 ge value 123145302310912 lt and {
          value       peekImm32
          value 4 add peekImm32 16777215 band 4294967296 mul
            add 8 div ==length
          0 length 1 sub range { 8 mul value add memDump } each
        } rep
        addr 8 add =addr
      } loop
      "^^^^^^^^^^^^^^^^^^\n" sys .out .writestr
    } /stackDump

    {
      currentScope peekImm64 heapDump
    } /globalScopeDump
  > -- 2 |deff rep
> /assemblerLibrary defv

# vim: syn=elymas
