"elymasAsm.ey" include

<
  256 ==INITIALEXTENSIONSIZE

  { assembler -01 . } ":" deff
  assembler .|label "@" deff
  "%" _ : -01 deff

  <
    1 ==PROT_READ
    2 ==PROT_WRITE
    4 ==PROT_EXEC

    2 ==MAP_PRIVATE
    16 ==MAP_FIXED
    32 ==MAP_ANONYMOUS
  > ==MMAP

  <
    9 ==mmap
  > ==SYSCALL

  { =*def ==struct
    struct values |cat fold :arrayToCode .base ==address
    struct keys { address -101 def struct -01 . len address add =address } each
  } /allocateOffsetStruct deff

  { ==str
    [
      str len :imm64 -- %10
      %00 %00 %00 %00 %00 %00 %00 %00
      str len :imm64
    ] str strToUTF8Bytes cat
    [ 8 str len 8 mod sub %00 rep ] cat
  } /toErrString deff

  <
    # current end of heap memory (grows upwards)
    [ %00 %00 %00 %00 %00 %60 %00 %00 ] ==heapEnd

    # next free byte at end of heap
    [ %00 %00 %00 %00 %00 %60 %00 %00 ] ==unusedHeapStart
    
    # current parser scope
    [ %00 %00 %00 %00 %00 %00 %00 %00 ] ==currentScope

    # current parser quote state
    [ %00 %00 %00 %00 %00 %00 %00 %00 ] ==currentQuoted

    # error strings
    "unresolved name: " toErrString ==errUnresolvedName
    "neither string nor array in len" toErrString ==errNeitherStringNorArrayInLen
    "not an executable thing" toErrString ==errNotExecutable
  > { defv }' allocateOffsetStruct

  { _ =*array len _ 4 div ==largeMoves
                    4 mod ==smallMoves
    0 ==i
    largeMoves {
      i _ 4 add =i
        _ [ 3 2 1 0 ] add array { -01 256 mul add } fold -01 /rdi :movlImmMemDisp8
    } rep
    i /rdi :addqImm8Reg
    smallMoves {
      i _ 1 add =i
          array /rdi :movbImmMem
      /rdi :incqReg
    } rep
  } /loadToRdi deff

  # internal functions, ABI follows SysV standards

  # compare two strings
  # rdi -> address of first string
  # rsi -> address of second string
  # rax <- 1 if both strings are equal, 0 otherwise
  [
    /rax /rax :xorqRegReg
    :cmpsq # ignore memory length header
    :cmpsq # ignore hash
    /rsi /rdx :movqMemReg # load exact length
    :cmpsq # same exact length
    /fail :jnzLbl8
    /rdx /rcx :movqRegReg
    :repz :cmpsb
    /fail :jnzLbl8
    /rax :incqReg
    @fail
  ] :labelResolve /internalStringEqualsCode defv

  <
    # dump string to stderr for internal error reporting
    # rdi -> address of string on heap
    [
      24 /rdi /rsi :leaqMemDisp8Reg
      16 /rdi /rdx :movqMemDisp8Reg
      2 /rdi :movqImmReg
      1 /rax :movqImmReg
      :syscall
      :retn
    ] /internalDumpErrorString defv

    # allocate a chunk of memory
    # rdi -> size of chunk in bytes
    # rax <- address of allocated chunk
    #        chunk will have GC length header initialized correctly
    # FIXME put a real allocator here
    [
      /rbx :pushqReg
      /rdi :pushqReg
      unusedHeapStart /rax :movqImmReg
      /rax /rcx :movqMemReg
      /rcx /rbx :movqRegReg
      /rcx /rdx :movqRegReg
      /rdi /rcx :addqRegReg
      /rcx /rax :movqRegMem
      heapEnd /rax :movqImmReg
      /rax /rdi :movqMemReg
      /rdi /rcx :cmpqRegReg
      [
        4096 4096 mul /rsi :movqImmReg
        /rsi /rdi :addqRegReg
        /rdi /rax :movqRegMem
        /rsi /rdi :subqRegReg

        SYSCALL .mmap /rax :movqImmReg
        # /rdi already fine
        # /rsi already fine
        < { MMAP -01 . } "!" deff
          !PROT_READ !PROT_WRITE !PROT_EXEC bor bor /rdx :movqImmReg
          !MAP_PRIVATE !MAP_FIXED !MAP_ANONYMOUS bor bor /r10 :movqImmReg
        > --
        /r8 :movqImmOOBReg %FF %FF %FF %FF %FF %FF %FF %FF
        0 /r9 :movqImmReg
        :syscall
      ] |len { :jbeRel8 } -21*0*221* dearray
      /rbx /rax :movqRegReg
      /rdi :popqReg
      /rdi /rax :movqRegMem
      /rbx :popqReg
      :retn
    ] /internalAllocate defv

    # compare two strings
    # rdi -> address of first string
    # rsi -> address of second string
    # rax <- 1 if both strings are equal, 0 otherwise
    [
      internalStringEqualsCode _ len dearray
      :retn
    ] /internalStringEquals defv

    # resolve element from scope
    # rdi -> address of scope on the heap
    # rsi -> address of element name on the heap
    # rax <- address of element on the heap (0 if nonexistant)
    # rdx <- 0 if element is passive
    #        1 if element is active
    #        2 if element is quote-active
    [
      @retryWithParent

      8 /rdi /rcx :movqMemDisp8Reg # load name table
      /rcx /rdx :movqRegReg
      16 /rdx :addqImm8Reg # rdx will iterate over entries
      8 /rcx /rcx :addqMemDisp8Reg # compute name table effective end

      @loop
      /rdx /rcx :cmpqRegReg
      /end :jbeLbl8
      # TODO this is ridiculous
      /rdi :pushqReg
      /rsi :pushqReg
      /rdx :pushqReg
      /rcx :pushqReg
      /rdx /rdi :movqMemReg
      internalStringEqualsCode _ len dearray
      /rcx :popqReg
      /rdx :popqReg
      /rsi :popqReg
      /rdi :popqReg

      /rax /rax :testqRegReg
      /found :jnzLbl8

      16 /rdx :addqImm8Reg
      /loop :jmpLbl8
      @end

      # not found at all, retry with parent
      16 /rdi /rdi :movqMemDisp8Reg
      /rdi /rdi :testqRegReg
      /retryWithParent :jnzLbl8

      @failed
      /rax /rax :xorqRegReg
      /rdx /rdx :xorqRegReg
      :retn

      @found
      8 /rdx /rax :movqMemDisp8Reg # load default activation
      8 /rdi /rdx :subqMemDisp8Reg # substract name table start
      16 /rdx :subqImm8Reg # substract name table header size
      /rdx :shrq1Reg # divide by 2 to get offset within scope

      # rdx == entry index * 8 in scope
      # rax == entry default activation

      32 /rdx :addqImm8Reg # add scope header size
      /edx /rdi :cmplRegMem # TODO this fails for > 4 GB scopes
      /inDataArea :jaLbl8

      /rdi /edx :sublMemReg # substract scope length
      24 /rdi /rdi :movqMemDisp8Reg # load extension area pointer
      /rdi /rdi :testqRegReg
      /outsideExtensionArea :jzLbl8
      8 /rdx :addqImm8Reg # add extension area header length

      @inDataArea
      /rdx /rdi /rdx :movqMemIndexReg # load entry pointer
      /rax /rdx :xchgqRegReg
      :retn

      @outsideExtensionArea
      /rax /rax :xorqRegReg
      :retn
    ] :labelResolve /internalResolve defv
  > { defv }' allocateOffsetStruct

  # TODO: link internal functions statically with relative calls
  <
    # allocate scope, expecting rdi entries
    # rdi -> expected number of entries
    # rsi -> parent scope
    # rax <- address of scope on the heap
    [
      /rsi :pushqReg
      /rdi :pushqReg
      
      # allocate name table
      4 /rdi :shlqImm8Reg
      16 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %30 7 /rax :orbImmMemDisp8

      # set fill to header size
      16 8 /rax :movqImm32MemDisp8

      /rdi :popqReg
      /rax :pushqReg # save name table on the stack

      3 /rdi :shlqImm8Reg
      32 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type and existence of all pointers
      %26 7 /rax :orbImmMemDisp8
      8 /rax :popqMemDisp8 # reference name table
      16 /rax :popqMemDisp8 # set parent
      /rdi /rdi :xorqRegReg # zero extension
      /rdi 24 /rax :movqRegMemDisp8

      :retn
    ] /internalAllocateScope defv

    # allocate function
    # rdi -> code pointer
    # rsi -> scope pointer
    # rdx -> type pointer
    # rax <- address of function on the heap
    [
      /rdi :pushqReg
      /rdx :pushqReg

      32 /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %50 7 /rax :orbImmMemDisp8

      /rsi 8 /rax :movqRegMemDisp8
      /rdx :popqReg
      /rdx 16 /rax :movqRegMemDisp8
      /rdi :popqReg
      /rdi 24 /rax :movqRegMemDisp8

      :retn
    ] /internalAllocateFunction defv

    # allocate code block
    # rdi -> number of code bytes
    # rax <- address of code block on heap
    [
      8 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %60 7 /rax :orbImmMemDisp8
      :retn
    ] /internalAllocateCode defv

    # allocate array, expecting rdi/8 entries
    # rdi -> expected number of entry bytes
    # rax <- address of array on the heap
    [
      8 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %70 7 /rax :orbImmMemDisp8

      :retn
    ] /internalAllocateArray defv
  > { defv }' allocateOffsetStruct

  [
    8 /r15 :subqImm8Reg
    /r15 :popqMem
    8 /r15 :subqImm8Reg
    currentScope /rbx :movqImmReg
    /rbx /rsi :movqMemReg
    /rsi /r15 :movqRegMem
  ] _ /unscopingFunctionHeader defv [
    8 /rdi :movqImmReg
    internalAllocateScope /rax :movqImmReg
    /rax :callqReg
    /rax /rbx :movqRegMem
  ] cat /scopingFunctionHeader defv

  [
    /r15 /rcx :movqMemReg
    currentScope /rax :movqImmReg
    /rcx /rax :movqRegMem
    8 /r15 :addqImm8Reg
    /r15 :pushqMem
    8 /r15 :addqImm8Reg
    :retn
  ] /functionFooter defv

  # elymas functions, stack based ABI

  1 ==ARRAYMARKER
  2 ==QUOTEMARKER

  # 0 -> integer
  # 1 -> integer
  # 0 <- result of the arithmetic operation
  { ==opcodes
    [
      /rbx :popqReg

      # allocate result int
      16 /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # type zero does not need to be changed

      # actual calculation
      /rcx :popqReg
      8 /rcx /rcx :movqMemDisp8Reg

      /rdx :popqReg
      8 /rdx /rdx :movqMemDisp8Reg

      opcodes _ len dearray
      /rdx 8 /rax :movqRegMemDisp8

      # push int address on program stack
      /rax :pushqReg
      /rbx :pushqReg
      :retn
    ]
  } /makeArith deff

  <
    # do nothing
    [
      :retn
    ] /ey/ defv

    # resolve in scope but never execute
    [
      /rcx :popqReg
      /rax :popqReg
      /rcx :pushqReg
      /rax :pushqReg

      # scope resolution
      currentScope /rdi :movqImmReg
      /rdi /rdi :movqMemReg
      /rsi :popqReg
      internalResolve /rax :movqImmReg
      /rax :callqReg

      /rcx :popqReg
      /rax :pushqReg
      /rcx :pushqReg
      :retn
    ] /ey| defv

    # arithmetic functions on ints
    [ /rcx /rdx :addqRegReg ] makeArith /eyadd defv
    [ /rcx /rdx :subqRegReg ] makeArith /eysub defv
    [ /rcx /rdx :andqRegReg ] makeArith /eyband defv
    [ /rcx /rdx :orqRegReg ] makeArith /eybor defv
    [ /rcx /rdx :xorqRegReg ] makeArith /eybxor defv
    [
      /rdi /rdi :xorqRegReg
      1 /rsi :movqImmReg
      /rdx /rcx :cmpqRegReg 
      /rsi /rdx :movqRegReg
      /rdi /rdx :cmovaeqRegReg
    ] makeArith /eygt defv
    [
      /rdi /rdi :xorqRegReg
      1 /rsi :movqImmReg
      /rdx /rcx :cmpqRegReg 
      /rsi /rdx :movqRegReg
      /rdi /rdx :cmovaqRegReg
    ] makeArith /eyge defv

    { ==activation
      # create a new entry in the current scope for the given name
      # mark that entry's default action according to activation
      # 0 -> name, string
      # 1 -> object
      [
        8 /r15 :subqImm8Reg
        /r15 :popqMem

        /rdi :popqReg

        # search for name in nametable
        currentScope /rax :movqImmReg
        /rax /rbx :movqMemReg # rbx == start of scope in heap
        8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
        8 /rbx /rsi :movqMemDisp8Reg # rsi == start of nametable in heap
        8 /rsi /rsi :addqMemDisp8Reg # rsi == end of nametable in heap (according to fill)

        @nameSearch
        16 /rdx :addqImm8Reg

        # rsi: end of nametable
        # rdx: current element of nametable

        /rdx /rsi :cmpqRegReg
        /nameUndefined :jbeLbl8

        /rdx :pushqReg
        /rsi :pushqReg
        /rdi :pushqReg
        /rcx :pushqReg
        /rdx /rsi :movqMemReg
        internalStringEqualsCode _ len dearray
        /rcx :popqReg
        /rdi :popqReg
        /rsi :popqReg
        /rdx :popqReg
        /rax /rax :testqRegReg
        /nameOffsetKnown :jnzLbl8

        # if not exists, insert
        @nameUndefined
        8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
        /rdx /eax :movlMemReg # add memory length to obtain memory end
        /rax /rdx :addqRegReg

        /rsi /rdx :cmpqRegReg
        /enlargeNameTable :jbeLbl8

        # insert into name table
        @insertIntoNameTable
        /rdi /rsi :movqRegMem
        activation 8 /rsi :movqImm32MemDisp8 # set default activation mode
        8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
        16 8 /rdx :addqImm8MemDisp8 # increment fill
        /rsi /rdx :movqRegReg
        /nameOffsetKnown :jmpLbl8

        @enlargeNameTable
        # if name table is already full, double size
        8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
        /rdi :pushqReg
        /rdx :pushqReg
        /rdx /edi :movlMemReg # load current length
        /rdi /rdi :addqRegReg

        internalAllocate /rax :movqImmReg
        /rax :callqReg
        %30 7 /rax :orbImmMemDisp8 # set type
        /rdx :popqReg
        8 /rdx /rcx :movqMemDisp8Reg
        /rcx 8 /rax :movqRegMemDisp8 # copy fill

        16 /rdx /rsi :leaqMemDisp8Reg
        16 /rax /rdi :leaqMemDisp8Reg
        16 /rcx :subqImm8Reg
        3 /rcx :shrqImm8Reg
        :reprcx :movsq # copy content

        # rax == enlarged name table on heap
        
        /rax 8 /rbx :movqRegMemDisp8 # switch scope to new name table

        # insert into name table
        /rsi :popqReg
        /rsi /rdi :xchgqRegReg
        /insertIntoNameTable :jmpLbl8
        
        @nameOffsetKnown
        8 /rbx /rdx :subqMemDisp8Reg # substract name table address
        16 /rdx :subqImm8Reg # substract name table header size
        /rdx :shrq1Reg # divide by 2 to get offset within scope

        # rdx == offset in scope
        # top of stack: the object to store

        # update 
        # if fits within main area, fine
        32 /rdx :addqImm8Reg # add scope header size
        /edx /rbx :cmplRegMem
        /inDataArea :jaLbl8

        # update within extension area
        /rbx /edx :sublMemReg # substract scope length
        24 /rbx /rdi :movqMemDisp8Reg # load extension area pointer
        8 /rdx :addqImm8Reg # add extension area header length

        # if extension area is non-existent, create
        /rdi /rdi :testqRegReg
        /extensionAreaExists :jnzLbl8

        /rdx :pushqReg
        INITIALEXTENSIONSIZE /rdi :movqImmReg
        internalAllocate /rax :movqImmReg
        /rax :callqReg
        /rdx :popqReg

        /rax /rdi :movqRegReg
        /rdi 24 /rbx :movqRegMemDisp8 # store new extension area
        /inExtensionArea :jmpLbl8

        @extensionAreaExists

        # if extension area is full, double size
        /edx /rdi :cmplRegMem
        /inExtensionArea :jnbLbl8

        # FIXME
        :ud2

        @inExtensionArea
        /rdi /rbx :movqRegReg

        @inDataArea

        /rax :popqReg
        /rax /rbx /rdx :movqRegMemIndex # save entry pointer

        /r15 :pushqMem
        8 /r15 :addqImm8Reg
        :retn
      ] :labelResolve
    } 0 -101* /eydefv defv
      1 -101* /eydeff defv
      2  -01* /eydefq defv

    # execute top stack element
    # 0 -> function to execute
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      /rdx :popqReg

      7 /rdx /cl :movbMemDisp8Reg
      %F0 /cl :andbImmReg
      %50 /cl :cmpbImmReg
      /normalFunction :jeLbl8
      %70 /cl :cmpbImmReg
      /arrayFunction :jeLbl8

      errNotExecutable /rdi :movqImmReg
      internalDumpErrorString /rax :movqImmReg
      /rax :callqReg
      :ud2

      @normalFunction
      # save current scope
      currentScope /rax :movqImmReg
      /rax /rsi :movqMemReg
      8 /r15 :subqImm8Reg
      /rsi /r15 :movqRegMem

      # enter scope
      8 /rdx /rcx :movqMemDisp8Reg
      /rcx /rcx :testqRegReg
      /unscoped :jzLbl8
      /rcx /rax :movqRegMem
      @unscoped

      # handle typed function
      16 /rdx /rcx :movqMemDisp8Reg
      /rcx /rcx :testqRegReg
      /typed :jnzLbl8

      24 /rdx /rax :movqMemDisp8Reg
      8 /rax :addqImm8Reg
      /rax :callqReg
      /done :jmpLbl8

      @done
      /r15 /rcx :movqMemReg
      currentScope /rax :movqImmReg
      /rcx /rax :movqRegMem
      8 /r15 :addqImm8Reg
      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn

      @arrayFunction
      # rdx == array on heap
      /rbx :popqReg

      7 /rbx /cl :movbMemDisp8Reg
      %F0 /cl :andbImmReg
      %00 /cl :cmpbImmReg
      /arrayIntArgument :jeLbl8
      :ud2 # TODO handle the fully typed case

      @arrayIntArgument
      8 /rbx /rax :movqMemDisp8Reg # rax == requested index
      /rdx /ecx :movlMemReg # load array length
      3 /rcx :shrqImm8Reg # divide by object pointer size
      /rcx :decqReg # rcx == number of elements in array

      /rsi /rsi :xorqRegReg
      /rdx /rsi :xchgqRegReg

      # TODO: think about skipping this if index fits
      /rcx :divqReg

      # rsi == array object on heap
      # rdx == correct array index
      8 8 /rdx /rsi :pushqMemIndexScaleDisp8 # use some of the CISC goodness

      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn

      @typed
      :ud2 # TODO handle typed functions and autolooping
    ] :labelResolve /ey* defv

    # dump top stack element (actually drop it for now)
    # FIXME: this belongs in the standard library
    [
      /rax :popqReg
      /rcx :popqReg
      /rax :pushqReg
      :retn
    ] /eydump defv

    # array construction, push begin marker on stack
    [
      /rax :popqReg
      ARRAYMARKER :pushqImm32
      /rax :pushqReg
      :retn
    ] /ey[ defv

    # array construction, create array from begin marker onwards
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      ARRAYMARKER /rax :movqImmReg
      /rsp /rdi :movqRegReg
      8 /rdi :subqImm8Reg
      @search
      8 /rdi :addqImm8Reg
      /rdi /rax :cmpqMemReg
      /search :jneLbl8

      /rdi /rcx :movqRegReg
      /rsp /rdi :subqRegReg
      /rcx :pushqReg

      # rdi == size of array
      internalAllocateArray /rax :movqImmReg
      /rax :callqReg
       
      /rdi :popqReg
      /rax /rdi :movqRegMem # store array pointer instead of begin marker

      /rax /ecx :movlMemReg
      3 /rcx :shrqImm8Reg
      /rcx :decqReg # rcx == number of array elements
      /rcx /rcx :testqRegReg
      /empty :jzLbl8

      8 /rcx /rax /rax :leaqMemIndexScaleReg # rax == address of last cell
      @copy
      /rax :popqMem
      8 /rax :subqImm8Reg
      /copy :loopLbl8

      @empty
      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /ey] defv

    # length of array or string
    # 0 -> array / string
    # 0 <- number of elements / characters
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem
      
      /rax :popqReg
      7 /rax /cl :movbMemDisp8Reg
      %F0 /cl :andbImmReg
      %10 /cl :cmpbImmReg
      /stringLen :jeLbl8
      %70 /cl :cmpbImmReg
      /arrayLen :jeLbl8

      errNeitherStringNorArrayInLen /rdi :movqImmReg
      internalDumpErrorString /rax :movqImmReg
      /rax :callqReg
      :ud2

      @arrayLen
      /rax /rbx :movqMemReg
      8 /rbx :shlqImm8Reg # clear type bits
      11 /rbx :shrqImm8Reg # divide by 8
      /rbx :decqReg # substract header size
      /done :jmpLbl8

      @stringLen
      16 /rax /rbx :movqMemDisp8Reg

      @done
      16 /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg
      /rax :pushqReg # push integer on the stack
      
      /rbx 8 /rax :movqRegMemDisp8 # store integer value

      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /eylen defv

    # create an array containing a continuous range of ints
    # 0 -> last element included in range
    # 1 -> first element included in range
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      8 /r15 :subqImm8Reg
      /r15 :popqMem

      8 /r15 :subqImm8Reg
      /r15 :popqMem

      # 8 /r15 == last element
      # /r15 == first element

      8 /r15 /rdi :movqMemDisp8Reg
      8 /rdi /rdi :movqMemDisp8Reg
      /r15 /rbx :movqMemReg
      8 /rbx /rbx :movqMemDisp8Reg

      /rbx /rdi :subqRegReg
      3 /rdi :shlqImm8Reg
      8 /rdi :addqImm8Reg # one extra element, TODO: consider whether this is actually a good idea
      internalAllocateArray /rax :movqImmReg
      /rax :callqReg

      /rax :pushqReg # store array on stack

      8 /rax /rdi :leaqMemDisp8Reg # fill target
      8 /r15 /rax :movqMemDisp8Reg
      8 /rax /rax :movqMemDisp8Reg # largest element

      @fill
      /rax /rbx :cmpqRegReg
      /done :jaLbl8

      /rax :pushqReg
      /rdi :pushqReg
      # create int
      16 /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg
      /rbx 8 /rax :movqRegMemDisp8 # store value
      /rdi :popqReg
      /rax /rdi :movqRegMem # store into array
      /rax :popqReg

      /rbx :incqReg
      8 /rdi :addqImm8Reg
      /fill :jmpLbl8

      @done

      16 /r15 :addqImm8Reg
      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /eyrange defv
  > _ ==globalFunctions { defv }' allocateOffsetStruct

  {
    :quoteEncodingBuffer /rax :movqImmReg
    /rax /rdi :subqRegReg
    /rdi :pushqReg # store opcode byte count

    /rdi :decqReg
    3 /rdi :shrqImm8Reg
    /rdi :incqReg
    3 /rdi :shlqImm8Reg
    internalAllocateCode /rax :movqImmReg
    /rax :callqReg

    # rax == code block on heap

    # copy opcodes
    :quoteEncodingBuffer /rsi :movqImmReg
    8 /rax /rdi :leaqMemDisp8Reg
    /rcx :popqReg
    :reprcx :movsb
  } /allocateCodeFromEncodingBuffer deff

  <
    <
      # resolve identifier according to current scope and quote mode and act accordingly
      # 0 -> identifier to resolve
      [
        8 /r15 :subqImm8Reg
        /r15 :popqMem

        /selfBegin :callLbl32
        ] _ len ==internalExecuteHeaderLen [ -011 len dearray
        @selfBegin
        /rax :popqReg
        internalExecuteHeaderLen /rax :subqImm8Reg
        8 /r15 :subqImm8Reg
        /rax /r15 :movqRegMem # store entry into this function

        8 /r15 :subqImm8Reg
        /r15 :popqMem # store identifier
        
        # scope resolution
        currentScope /rdi :movqImmReg
        /rdi /rdi :movqMemReg
        /r15 /rsi :movqMemReg
        internalResolve /rax :movqImmReg
        /rax :callqReg

        /rax /rax :testqRegReg
        /unresolved :jzLbl8
        /rax :pushqReg

        0 /rdx :cmpqImm8Reg
        /inactive :jzLbl8
        1 /rdx :cmpqImm8Reg
        /active :jzLbl8
        2 /rdx :cmpqImm8Reg
        /quoteActive :jzLbl8

        # TODO: "invalid activation mode"
        :ud2

        @unresolved
        currentQuoted /rax :movqImmReg
        /rax /rax :movqMemReg
        /rax /rax :testqRegReg
        /constructQuotedResolve :jnzLbl8

        errUnresolvedName /rdi :movqImmReg
        internalDumpErrorString /rax :movqImmReg
        /rax :callqReg
        /r15 /rdi :movqMemReg
        internalDumpErrorString /rax :movqImmReg
        /rax :callqReg
        :ud2

        @quoteActive
        |ey* /rax :movqImmReg
        /rax :callqReg
        /done :jmpLbl8

        @active
        currentQuoted /rax :movqImmReg
        /rax /rax :movqMemReg
        /rax /rax :testqRegReg
        /activeQuoted :jnzLbl8
        |ey* /rax :movqImmReg
        /rax :callqReg
        /done :jmpLbl8

        @activeQuoted
        # FIXME: actually, this should re-resolve as if unresolved
        /done :jmpLbl8

        @inactive
        currentQuoted /rax :movqImmReg
        /rax /rax :movqMemReg
        /rax /rax :testqRegReg
        /constructQuotedResolve :jnzLbl8

        @done
        16 /r15 :addqImm8Reg
        /r15 :pushqMem
        8 /r15 :addqImm8Reg
        :retn

        @constructQuotedResolve
        # construct non-capturing function which
        :quoteEncodingBuffer /rdi :movqImmReg
        unscopingFunctionHeader loadToRdi

        # 1. pushes identifier
        [ /rax :movqImmOOBReg ] _ len 2 eq assert
          2 dearray 256 mul add 
          /rdi :movwImmMem
        /r15 /rsi :movqMemReg
        /rsi 2 /rdi :movqRegMemDisp8
        10 /rdi :addqImm8Reg

        [
          /rax :pushqReg

          # 2. resets to non-quoted mode
          8 /r15 :subqImm8Reg
          currentQuoted /rax :movqImmReg
          /rax /rcx :movqMemReg
          /rcx /r15 :movqRegMem
          /rcx /rcx :xorqRegReg
          /rcx /rax :movqRegMem
          # 3. resolves identifier action
          /rax :movqImmOOBReg
        ] loadToRdi
        8 /r15 /rax :movqMemDisp8Reg
        /rax /rdi :movqRegMem
        8 /rdi :addqImm8Reg
        [
          /rax :callqReg
          # 4. restores quote mode
          /r15 /rcx :movqMemReg
          currentQuoted /rax :movqImmReg
          /rcx /rax :movqRegMem
          8 /r15 :addqImm8Reg
        ] functionFooter cat loadToRdi

        allocateCodeFromEncodingBuffer
        # rax == code block on heap

        # create non-capturing function object
        /rax /rdi :movqRegReg
        /rsi /rsi :xorqRegReg
        /rdx /rdx :xorqRegReg
        internalAllocateFunction /rax :movqImmReg
        /rax :callqReg

        # rax == function object on heap
        /rax :pushqReg
        /done :jmpLbl32
      ] :labelResolve
    > -- /internalExecuteIdentifier defv
  > { defv }' allocateOffsetStruct

  <
    # drop top stack element
    [
      /rax :popqReg
      /rcx :popqReg
      /rax :pushqReg
      :retn
    ] /ey-- defv

    # duplicate top stack element
    [
      /rax :popqReg
      /rcx :popqReg
      /rcx :pushqReg
      /rcx :pushqReg
      /rax :pushqReg
      :retn
    ] /ey_ defv

    # top stack element is a string defining a stack shuffle
    # 0-9: push the thusly numbered element
    #   *: execute top element
    # pops as many elements as the highest number specifies
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem
      80 /r15 :subqImm8Reg

      /rdi :popqReg
      16 /rdi /rcx :movqMemDisp8Reg # load string length
      24 /rdi /rax :leaqMemDisp8Reg # rax to begin of string

      42 /rsi :movqImmReg # initialize with '*'

      # find maximal element, note that '*' < '0'
      @maximalElementSearch
      /rax /rdx :movzxMem8Reg64
      /rsi /rdx :cmpqRegReg
      /rdx /rsi :cmovaqRegReg
      /rax :incqReg
      /maximalElementSearch :loopLbl8

      # move elements to temporary storage
      42 /rsi :cmpqImm8Reg
      /elementsSaved :jeLbl8
      
      47 /rsi :subqImm8Reg # substract '0'-1
      /rsi /rcx :movqRegReg
      /rsi /rsi :xorqRegReg

      @saveElements
      8 /rsi /r15 :popqMemIndexScale
      /rsi :incqReg
      /saveElements :loopLbl8

      # execute shuffle specification
      @elementsSaved
      16 /rdi /rcx :movqMemDisp8Reg # load string length
      24 /rdi /rax :leaqMemDisp8Reg # rax to begin of string

      @executeSpec
      /rax /rdx :movzxMem8Reg64
      /rax :incqReg

      42 /rdx :cmpqImm8Reg
      /executeTop :jeLbl8

      48 /rdx :subqImm8Reg # substract '0'
      8 /rdx /r15 :pushqMemIndexScale
      /executeSpec :loopLbl8
      /done :jmpLbl8

      @executeTop
      24 /r15 :subqImm8Reg
      /rax 16 /r15 :movqRegMemDisp8
      /rcx 8 /r15 :movqRegMemDisp8
      /rdx /r15 :movqRegMem
      |ey* /rax :movqImmReg
      /rax :callqReg
      /r15 /rdx :movqMemReg
      8 /r15 /rcx :movqMemDisp8Reg
      16 /r15 /rax :movqMemDisp8Reg
      24 /r15 :addqImm8Reg
      /executeSpec :loopLbl8

      @done
      80 /r15 :addqImm8Reg
      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /ey- defv

    # execute top stack element multiple times
    # 0 -> function to execute
    # 1 -> how often to execute it
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      8 /r15 :subqImm8Reg
      /r15 :popqMem # store function to call

      8 /r15 :subqImm8Reg
      /rcx :popqReg
      8 /rcx /rcx :movqMemDisp8Reg

      @loop
      /rcx /r15 :movqRegMem
      
      8 /r15 :pushqMemDisp8
      |ey* /rax :movqImmReg
      /rax :callqReg

      /r15 /rcx :movqMemReg
      /loop :loopLbl8
      
      16 /r15 :addqImm8Reg

      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /eyrep defv

    # a normal loop
    # 0 -> second part of loop
    # 1 -> first part of loop
    # execute first part, if top of stack is nonzero, execute second part, repeat
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      8 /r15 :subqImm8Reg
      /r15 :popqMem

      8 /r15 :subqImm8Reg
      /r15 :popqMem

      # /r15 -> first part
      # 8 /r15 -> second part

      @loop
      /r15 :pushqMem
      |ey* /rax :movqImmReg
      /rax :callqReg

      /rax :popqReg
      0 8 /rax :cmpqImm8MemDisp8
      /end :jzLbl8

      8 /r15 :pushqMemDisp8
      |ey* /rax :movqImmReg
      /rax :callqReg
      /loop :jmpLbl8

      @end

      16 /r15 :addqImm8Reg

      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /eyloop defv

    # a foreach loop
    # 0 -> code to execute
    # 1 -> array to loop over
    # for each element in array, push it onto stack then execute the code
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      8 /r15 :subqImm8Reg
      /r15 :popqMem

      16 /r15 :subqImm8Reg
      
      /rax :popqReg
      8 /rax /rcx :leaqMemDisp8Reg
      /rcx /r15 :movqRegMem

      /rax /edx :movlMemReg
      1 /rdx /rax /rcx :leaqMemIndexScaleReg
      /rcx 8 /r15 :movqRegMemDisp8

      # /r15 -> current array element
      # 8 /r15 -> address after last array element
      # 16 /r15 -> code to execute

      @loop
      /r15 /rax :movqMemReg
      8 /r15 /rax :cmpqMemDisp8Reg
      /end :jnbLbl8

      /rax :pushqMem # push array element
      16 /r15 :pushqMemDisp8 # push code
      |ey* /rax :movqImmReg
      /rax :callqReg

      8 /r15 :addqImm8Mem
      /loop :jmpLbl8

      @end

      24 /r15 :addqImm8Reg
      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /eyeach defv
  > _ ==globalFunctions2 { defv }' allocateOffsetStruct

  <
    # quote construction, push begin marker on stack
    [
      /rax :popqReg
      QUOTEMARKER :pushqImm32
      currentQuoted /rcx :movqImmReg
      /rcx :incqMem
      /rax :pushqReg
      :retn
    ] /ey{ defv

    # quote construction, create function from begin marker onwards
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      currentQuoted /rcx :movqImmReg
      /rcx :decqMem

      QUOTEMARKER /rcx :movqImmReg
      /rcx :pushqReg
      /rsp /rdx :movqRegReg
      @backwardsSearch
      8 /rdx :addqImm8Reg
      /rdx /rcx :cmpqMemReg
      /backwardsSearch :jneLbl8

      /rdx :pushqReg # store address of begin marker

      :quoteEncodingBuffer /rdi :movqImmReg
      scopingFunctionHeader loadToRdi

      @search
      8 /rdx :subqImm8Reg
      /rdx /rcx :cmpqMemReg
      /markerFound :jeLbl8

      /rdx /rsi :movqMemReg
      7 /rsi /al :movbMemDisp8Reg
      %F0 /al :andbImmReg
      /immediateFound :jzLbl8
      %10 /al :cmpbImmReg
      /immediateFound :jzLbl8
      %50 /al :cmpbImmReg
      /functionFound :jzLbl8
      %70 /al :cmpbImmReg
      /arrayFound :jzLbl8

      # TODO: "invalid object during quote construction"
      :ud2

      @immediateFound
      [ /rax :movqImmOOBReg ] _ len 2 eq assert
        2 dearray 256 mul add 
        /rdi :movwImmMem
      /rsi 2 /rdi :movqRegMemDisp8
      [ /rax :pushqReg ] _ len 1 eq assert
        1 dearray
        10 /rdi :movbImmMemDisp8
      11 /rdi :addqImm8Reg
      /search :jmpLbl8

      @functionFound
      [ /rax :movqImmOOBReg ] _ len 2 eq assert
        2 dearray 256 mul add 
        /rdi :movwImmMem
      /rsi 2 /rdi :movqRegMemDisp8
      [ /rax :pushqReg ] _ len 1 eq assert
        1 dearray
        10 /rdi :movbImmMemDisp8
      11 /rdi :addqImm8Reg
      [
        |ey* /rax :movqImmReg
        /rax :callqReg
      ] loadToRdi
      /search :jmpLbl8

      @arrayFound
      # FIXME allow macros to put byte arrays into quoted contexts and thereby generate assembly
      :ud2
      /search :jmpLbl8

      @markerFound

      functionFooter loadToRdi
      allocateCodeFromEncodingBuffer

      # rax == code block on heap

      currentQuoted /rcx :movqImmReg
      /rcx /rcx :movqMemReg
      /rcx /rcx :testqRegReg
      /quoted :jnzLbl8

      # create function object
      /rax /rdi :movqRegReg
      currentScope /rax :movqImmReg
      /rax /rsi :movqMemReg
      /rdx /rdx :xorqRegReg
      internalAllocateFunction /rax :movqImmReg
      /rax :callqReg

      @done
      # rax == function object on heap

      # store function instead of begin marker
      /rdx :popqReg
      /rax /rdx :movqRegMem
      /rdx /rsp :movqRegReg # and drop quoted stuff from stack

      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn

      @quoted
      # rax == (inner) code object on heap

      # create function which
      # returns a function with the current scope captured
      :quoteEncodingBuffer /rdi :movqImmReg
      unscopingFunctionHeader loadToRdi

      # 1. load inner code block
      [ /rdi :movqImmOOBReg ] _ len 2 eq assert
        2 dearray 256 mul add 
        /rdi :movwImmMem
      /rax 2 /rdi :movqRegMemDisp8
      10 /rdi :addqImm8Reg

      [
        currentScope /rax :movqImmReg
        /rax /rsi :movqMemReg
        /rdx /rdx :xorqRegReg
        internalAllocateFunction /rax :movqImmReg
        /rax :callqReg
        /rax :pushqReg
      ] functionFooter cat loadToRdi
      
      allocateCodeFromEncodingBuffer

      # rax == code object on heap

      # create function object
      /rax /rdi :movqRegReg
      /rsi /rsi :xorqRegReg # non-capturing
      /rdx /rdx :xorqRegReg
      internalAllocateFunction /rax :movqImmReg
      /rax :callqReg

      # rax == function object on heap

      /done :jmpLbl32
    ] :labelResolve /ey} defv
  > _ ==globalMacros { defv }' allocateOffsetStruct

  { strToUTF8Bytes _ =*v len _ ==exactLength
    1 sub 8 div 4 add 8 mul ==memoryLength

    memoryLength 2147483648 lt assert

    [
      # allocate string
      memoryLength /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # push string address on program stack
      /rax :pushqReg

      # set type
      7 /rax :addqImm8Reg
      %10 /rax :orbImmMem

      # clear hash value
      1 /rax :addqImm8Reg
      /rdx /rdx :xorqRegReg
      /rdx /rax :movqRegMem 

      # load exact length
      8 /rax :addqImm8Reg
      exactLength /rdx :movqImmReg
      /rdx /rax :movqRegMem 

      # load string contents
      0 exactLength 8 div range { 8 mul ==i
        8 /rax :addqImm8Reg
        /rdx :movqImmOOBReg i _ 7 add range v 8 dearray
        /rdx /rax :movqRegMem
      } each
    ]
  } /constStringCode deff

  [
    globalFunctions keys len globalFunctions2 keys len globalMacros keys len add add /rdi :movqImmReg
    /rsi /rsi :xorqRegReg
    internalAllocateScope /rax :movqImmReg
    /rax :callqReg

    currentScope /rdi :movqImmReg
    /rax /rdi :movqRegMem

    { ==createScopeEntry
      { ==name
        # create function
        name | 8 sub /rdi :movqImmReg
        /rsi /rsi :xorqRegReg # library functions don't have a captured scope
        # TODO: put a type here where applicable
        /rdx /rdx :xorqRegReg

        internalAllocateFunction /rax :movqImmReg
        /rax :callqReg
        /rax :pushqReg

        # create string
        name "ey(.*)" regex assert constStringCode _ len dearray

        # enter into current (i.e. global) scope
        createScopeEntry /rax :movqImmReg
        /rax :callqReg
      } each
    } /createScopeEntries deff
    globalFunctions keys eydeff createScopeEntries
    globalFunctions2 keys eydeff createScopeEntries
    globalMacros keys eydefq createScopeEntries
  ] :execute

  <
    [
      32 { "." } rep
      " " "!" "\"" "#" "$" "%" "&" "´" "(" ")" "*" "+" "," "-" "." "/"
      /0 /1 /2 /3 /4 /5 /6 /7 /8 /9 ":" ";" "<" "=" ">" "?"
      "@" /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P
      /Q /R /S /T /U /V /W /X /Y /Z "[" "\\" "]" "^" "_"
      "`" /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p
      /q /r /s /t /u /v /w /x /y /z "{" "|" "}" "~" "."
      128 { "." } rep
    ] /ASCII defv

    { # ==addr
      [ -01 7 add 8 { _ sys .asm .peek -01 1 sub } rep -- ] { -01 256 mul add } fold
    } /peekImm64 deff

    { # ==addr
      [ -01 3 add 4 { _ sys .asm .peek -01 1 sub } rep -- ] { -01 256 mul add } fold
    } /peekImm32 deff

    { # ==addr
      sys .asm .peek
    } /peekImm8 deff

    [ /0 /1 /2 /3 /4 /5 /6 /7 /8 /9 /A /B /C /D /E /F ] ==base16singleDigits
    [ base16singleDigits { ==first base16singleDigits { first -01 cat } each } each ] ==base16digits

    {
      [ -01 8 { _ 256 mod -01 256 div } rep -- ]
      base16digits *
      reverse |cat fold
    } /base16encode64 deff

    {
      [ -01 4 { _ 256 mod -01 256 div } rep -- ]
      base16digits *
      reverse |cat fold
    } /base16encode32 deff

    { ==objAddr
      "  int\n" sys .out .writestr
    } /intDump deff

    { ==objAddr
      "  \"" sys .out .writestr
      objAddr 16 add peekImm64 ==length
      objAddr 24 add _ length add 1 sub range peekImm8 ASCII * |cat fold sys .out .writestr
      "\"\n" sys .out .writestr
    } /stringDump deff

    { ==objAddr
      "  scope\n" sys .out .writestr

      objAddr       peekImm32
      objAddr 4 add peekImm32 16777215 band 4294967296 mul add ==length

      objAddr 8 add peekImm64 ==nameTable
      objAddr 16 add peekImm64 ==parent
      objAddr 24 add peekImm64 ==extensionArea

      nameTable 8 add peekImm64 ==nameTableEnd
      16 { _ nameTableEnd lt } {
        _ nameTable add base16encode64 ": " cat sys .out .writestr
        _ nameTable add peekImm64 stringDump
        _ 16 sub 2 div 32 add _ length lt { ==offset
            offset objAddr add peekImm64 memDump
          } { length sub 8 add ==offset
            offset extensionArea add peekImm64 memDump
          } ? *
        16 add
      } loop --
    } /scopeDump deff

    { ==objAddr
      "  nameTable\n" sys .out .writestr
    } /nameTableDump deff

    { ==objAddr
      "  extensionArea\n" sys .out .writestr
    } /extensionAreaDump deff

    { ==objAddr
      "  function\n" sys .out .writestr
    } /functionDump deff

    { ==objAddr
      "  code\n" sys .out .writestr
    } /codeDump deff

    { ==addr
      [
        "  "
        addr base16encode64
        ": "
        # the perl interpreter does not like full 64bit numbers and converts them into floats
        addr 4 add peekImm32 _ ==heapValueB base16encode32
        addr       peekImm32 _ ==heapValueA base16encode32
        " "
        [ [ heapValueA heapValueB ] { 4 { _ 256 mod -01 256 div } rep -- } each ] ASCII * 8 dearray
        "\n"
      ] |cat fold sys .out .writestr
    } /memDump deff

    { ==objAddr
      "Object at " objAddr base16encode64 cat " ----------\n" cat sys .out .writestr
      objAddr       peekImm32
      objAddr 4 add peekImm32 16777215 band 4294967296 mul
        add 8 div ==length
      0 length 1 sub range { 8 mul objAddr add memDump } each

      objAddr 7 add peekImm8 16 div
      [
        |intDump |stringDump |scopeDump |nameTableDump |extensionAreaDump |functionDump |codeDump |die
        |die |die |die |die |die |die |die |die
      ] *
      objAddr -01*
      "^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" sys .out .writestr
    } /heapDump deff

    {
      :mainStack .base :STACKSIZE add ==stackEnd
      "Stack ------------\n" sys .out .writestr
      :mainStack .base peekImm64 ==addr
      addr stackEnd gt { [ -01 stackEnd ] die } rep # Stack corrupted

      { addr stackEnd lt } {
        [
          addr base16encode64 ": "
          addr peekImm64 ==value
          value base16encode64
          "\n"
        ] |cat fold sys .out .writestr

        value 105553116266496 ge value 123145302310912 lt and {
          value       peekImm32
          value 4 add peekImm32 16777215 band 4294967296 mul
            add 8 div ==length
          0 length 1 sub range { 8 mul value add memDump } each
        } rep
        addr 8 add =addr
      } loop
      "^^^^^^^^^^^^^^^^^^\n" sys .out .writestr
    } /stackDump

    {
      currentScope peekImm64 heapDump
    } /globalScopeDump
  > -- 2 |deff rep
> /assemblerLibrary defv

# vim: syn=elymas
