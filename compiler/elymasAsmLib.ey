"elymasAsm.ey" include

<
  { assembler -01 . } ":" deff
  "%" _ : -01 deff

  <
    1 ==PROT_READ
    2 ==PROT_WRITE
    4 ==PROT_EXEC

    2 ==MAP_PRIVATE
    16 ==MAP_FIXED
    32 ==MAP_ANONYMOUS
  > ==MMAP

  <
    9 ==mmap
  > ==SYSCALL

  { =*def ==struct
    struct values |cat fold :arrayToCode .base ==address
    struct keys { address -101 def struct -01 . len address add =address } each
  } /allocateOffsetStruct deff

  <
    # current end of heap memory (grows upwards)
    [ %00 %00 %00 %00 %00 %60 %00 %00 ] ==heapEnd

    # next free byte at end of heap
    [ %00 %00 %00 %00 %00 %60 %00 %00 ] ==unusedHeapStart
    
    # current parser scope
    [ %00 %00 %00 %00 %00 %00 %00 %00 ] ==currentScope
  > { defv }' allocateOffsetStruct

  # internal functions, ABI follows SysV standards

  # compare two strings
  # rdi -> address of first string
  # rsi -> address of second string
  # rax <- 1 if both strings are equal, 0 otherwise
  [
    /rax /rax :xorqRegReg
    :cmpsq # ignore memory length header
    :cmpsq # ignore hash
    /rsi /rdx :movqMemReg # load exact length
    :cmpsq # same exact length
    /fail :jnzLbl8
    /rdx /rcx :movqRegReg
    :repz :cmpsb
    /fail :jnzLbl8
    /rax :incqReg
    /fail :label
  ] :labelResolve /internalStringEqualsCode defv

  <
    # allocate a chunk of memory
    # rdi -> size of chunk in bytes
    # rax <- address of allocated chunk
    #        chunk will have GC length header initialized correctly
    # FIXME put a real allocator here
    [
      /rbx :pushqReg
      /rdi :pushqReg
      unusedHeapStart /rax :movqImmReg
      /rax /rcx :movqMemReg
      /rcx /rbx :movqRegReg
      /rcx /rdx :movqRegReg
      /rdi /rcx :addqRegReg
      /rcx /rax :movqRegMem
      heapEnd /rax :movqImmReg
      /rax /rdi :movqMemReg
      /rdi /rcx :cmpqRegReg
      [
        4096 4096 mul /rsi :movqImmReg
        /rsi /rdi :addqRegReg
        /rdi /rax :movqRegMem
        /rsi /rdi :subqRegReg

        SYSCALL .mmap /rax :movqImmReg
        # /rdi already fine
        # /rsi already fine
        < { MMAP -01 . } "!" deff
          !PROT_READ !PROT_WRITE !PROT_EXEC bor bor /rdx :movqImmReg
          !MAP_PRIVATE !MAP_FIXED !MAP_ANONYMOUS bor bor /r10 :movqImmReg
        > --
        /r8 :movqImmOOBReg %FF %FF %FF %FF %FF %FF %FF %FF
        0 /r9 :movqImmReg
        :syscall
      ] |len { :jbeRel8 } -21*0*221* dearray
      /rbx /rax :movqRegReg
      /rdi :popqReg
      /rdi /rax :movqRegMem
      /rbx :popqReg
      :retn
    ] /internalAllocate defv

    # compare two strings
    # rdi -> address of first string
    # rsi -> address of second string
    # rax <- 1 if both strings are equal, 0 otherwise
    [
      internalStringEqualsCode _ len dearray
      :retn
    ] /internalStringEquals defv

    # resolve element from scope
    # rdi -> address of scope on the heap
    # rsi -> address of element name on the heap
    # rax <- address of element on the heap (0 if nonexistant)
    # rdx <- 0 if element is passive
    #        1 if element is active
    #        2 if element is quote-active
    [
      8 /rdi /rcx :movqMemDisp8Reg # load name table
      /rcx /rdx :movqRegReg
      16 /rdx :addqImm8Reg # rdx will iterate over entries
      8 /rcx /rcx :addqMemDisp8Reg # compute name table effective end

      /loop :label
      /rdx /rcx :cmpqRegReg
      /end :jbeLbl8
      # TODO this is ridiculous
      /rdi :pushqReg
      /rsi :pushqReg
      /rdx :pushqReg
      /rcx :pushqReg
      /rdx /rdi :movqMemReg
      internalStringEqualsCode _ len dearray
      /rcx :popqReg
      /rdx :popqReg
      /rsi :popqReg
      /rdi :popqReg

      /rax /rax :testqRegReg
      /found :jnzLbl8

      16 /rdx :addqImm8Reg
      /loop :jmpLbl8
      /end :label

      # not found at all, retry with parent
      # FIXME: Actually try with parent
      /rax /rax :xorqRegReg
      /rdx /rdx :xorqRegReg
      :retn

      /found :label
      8 /rdx /rax :movqMemDisp8Reg # load default activation
      8 /rdi /rdx :subqMemDisp8Reg # substract name table start
      16 /rdx :subqImm8Reg # substract name table header size
      /rdx :shrq1Reg # divide by 2 to get offset within scope

      # rdx == entry index * 8 in scope
      # rax == entry default activation

      32 /rdx :addqImm8Reg # add scope header size
      /edx /rdi :cmplRegMem # TODO this fails for > 4 GB scopes
      /inDataArea :jnbLbl8

      /rdi /edx :sublMemReg # substract scope length
      24 /rdi /rdi :movqMemDisp8Reg # load extension area pointer
      8 /rdx :addqImm8Reg # add extension area header length

      /inDataArea :label
      /rdx /rdi /rdx :movqMemIndexReg # load entry pointer
      /rax /rdx :xchgqRegReg
      :retn
    ] :labelResolve /internalResolve defv

  > { defv }' allocateOffsetStruct

  # TODO: link internal functions statically with relative calls
  <
    # allocate scope, expecting rdi entries
    # rdi -> expected number of entries
    # rsi -> parent scope
    # rax <- address of scope on the heap
    [
      /rdi :pushqReg
      
      # allocate name table
      4 /rdi :shlqImm8Reg
      16 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %30 7 /rax :orbImmMemDisp8

      # set fill to header size
      16 8 /rax :movqImm32MemDisp8

      /rdi :popqReg
      /rax :pushqReg # save name table on the stack

      3 /rdi :shlqImm8Reg
      32 /rdi :addqImm8Reg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type and existence of all pointers
      %26 7 /rax :orbImmMemDisp8
      # reference name table
      /rcx :popqReg
      /rcx 8 /rax :movqRegMemDisp8
      # zero parent and extension
      /rdi /rdi :xorqRegReg
      /rdi 16 /rax :movqRegMemDisp8
      /rdi 24 /rax :movqRegMemDisp8

      :retn
    ] /internalAllocateScope defv

    # allocate function
    # rdi -> code pointer
    # rsi -> scope pointer
    # rdx -> type pointer
    # rax <- address of function on the heap
    [
      /rdi :pushqReg
      /rdx :pushqReg

      32 /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # set type
      %50 7 /rax :orbImmMemDisp8

      /rsi 8 /rax :movqRegMemDisp8
      /rdx :popqReg
      /rdx 16 /rax :movqRegMemDisp8
      /rdi :popqReg
      /rdi 24 /rax :movqRegMemDisp8

      :retn
    ] /internalAllocateFunction defv
  > { defv }' allocateOffsetStruct

  <
    # elymas functions, stack based ABI

    # 0 -> integer
    # 1 -> integer
    # 0 <- sum of the above
    [
      /rbx :popqReg

      # allocate result int
      16 /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # type zero does not need to be changed

      # actual calculation
      /rcx :popqReg
      8 /rcx /rcx :movqMemDisp8Reg

      /rdx :popqReg
      8 /rdx /rdx :movqMemDisp8Reg

      /rcx /rdx :addqRegReg
      /rdx 8 /rax :movqRegMemDisp8

      # push int address on program stack
      /rax :pushqReg
      /rbx :pushqReg
      :retn
    ] /eyadd defv

    # create a new entry in the current scope for the given name
    # mark that entry as default-active
    # 0 -> name, string
    # 1 -> object
    [
      /rcx :popqReg
      /rdi :popqReg

      # search for name in nametable
      currentScope /rax :movqImmReg
      /rax /rbx :movqMemReg # rbx == start of scope in heap
      8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
      8 /rbx /rsi :movqMemDisp8Reg # rsi == start of nametable in heap
      8 /rsi /rsi :addqMemDisp8Reg # rsi == end of nametable in heap (according to fill)

      /nameSearch :label
      16 /rdx :addqImm8Reg

      # rsi: end of nametable
      # rdx: current element of nametable

      /rdx /rsi :cmpqRegReg
      /nameUndefined :jbeLbl8

      /rdx :pushqReg
      /rsi :pushqReg
      /rdi :pushqReg
      /rcx :pushqReg
      /rdx /rsi :movqMemReg
      internalStringEqualsCode _ len dearray
      /rcx :popqReg
      /rdi :popqReg
      /rsi :popqReg
      /rdx :popqReg
      /rax /rax :testqRegReg
      /nameOffsetKnown :jnzLbl8

      # if not exists, insert
      /nameUndefined :label
      8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
      /rdx /eax :movlMemReg # add memory length to obtain memory end
      /rax /rdx :addqRegReg

      /rsi /rdx :cmpqRegReg
      /enlargeNameTable :jbeLbl8

      # insert into name table
      /rdi /rsi :movqRegMem
      1 8 /rsi :movqImm32MemDisp8 # set default activation mode to execute
      8 /rbx /rdx :movqMemDisp8Reg # rdx == start of nametable in heap
      16 8 /rdx :addqImm8MemDisp8 # increment fill
      /rsi /rdx :movqRegReg
      /nameOffsetKnown :jmpLbl8

      /enlargeNameTable :label
      # if name table is already full, double size
      # FIXME
      :ud2
      
      /nameOffsetKnown :label
      8 /rbx /rdx :subqMemDisp8Reg # substract name table address
      16 /rdx :subqImm8Reg # substract name table header size
      /rdx :shrq1Reg # divide by 2 to get offset within scope

      # rdx == offset in scope
      # top of stack: the object to store

      # update 
      # if fits within main area, fine
      32 /rdx :addqImm8Reg # add scope header size
      /edx /rbx :cmplRegMem # TODO this fails for > 4 GB scopes
      /inDataArea :jnbLbl8

      # update within extension area
      /rbx /edx :sublMemReg # substract scope length
      24 /rbx /rbx :movqMemDisp8Reg # load extension area pointer
      8 /rdx :addqImm8Reg # add extension area header length

      # if extension area is full, double size
      /edx /rbx :cmplRegMem
      /inExtensionArea :jnbLbl8

      # FIXME
      :ud2

      /inExtensionArea :label
      /inDataArea :label

      /rax :popqReg
      /rax /rbx /rdx :movqRegMemIndex # save entry pointer

      /rcx :pushqReg
      :retn
    ] :labelResolve /eydeff defv

    # execute top stack element
    [
      8 /r15 :subqImm8Reg
      /r15 :popqMem

      /rdx :popqReg

      # enter scope
      8 /rdx /rcx :movqMemDisp8Reg
      /rcx /rcx :testqRegReg
      /scoped :jnzLbl8
      currentScope /rax :movqImmReg
      /rax /rcx :movqMemReg
      /scoped :label
      8 /r15 :subqImm8Reg
      /rcx /r15 :movqRegMem

      # handle typed function
      16 /rdx /rcx :movqMemDisp8Reg
      /rcx /rcx :testqRegReg
      /typed :jnzLbl8

      24 /rdx /rax :movqMemDisp8Reg
      8 /rax :addqImm8Reg
      /rax :callqReg
      /done :jmpLbl8

      /typed :label
      :ud2 # TODO handle typed functions and autolooping

      /done :label
      /r15 /rcx :movqMemReg
      currentScope /rax :movqImmReg
      /rcx /rax :movqRegMem
      8 /r15 :addqImm8Reg
      /r15 :pushqMem
      8 /r15 :addqImm8Reg
      :retn
    ] :labelResolve /ey* defv
  > _ ==globalFunctions { defv }' allocateOffsetStruct

  { strToUTF8Bytes _ =*v len _ ==exactLength
    1 sub 8 div 4 add 8 mul ==memoryLength

    memoryLength 2147483648 lt assert

    [
      # allocate string
      memoryLength /rdi :movqImmReg
      internalAllocate /rax :movqImmReg
      /rax :callqReg

      # push string address on program stack
      /rax :pushqReg

      # set type
      7 /rax :addqImm8Reg
      %10 /rax :orbImmMem

      # clear hash value
      1 /rax :addqImm8Reg
      /rdx /rdx :xorqRegReg
      /rdx /rax :movqRegMem 

      # load exact length
      8 /rax :addqImm8Reg
      exactLength /rdx :movqImmReg
      /rdx /rax :movqRegMem 

      # load string contents
      0 exactLength 8 div range { 8 mul ==i
        8 /rax :addqImm8Reg
        /rdx :movqImmOOBReg i _ 7 add range v 8 dearray
        /rdx /rax :movqRegMem
      } each
    ]
  } /constStringCode deff

  [
    globalFunctions keys len /rdi :movqImmReg
    internalAllocateScope /rax :movqImmReg
    /rax :callqReg

    currentScope /rdi :movqImmReg
    /rax /rdi :movqRegMem

    globalFunctions keys { ==name
      # create function
      name | 8 sub /rdi :movqImmReg
      currentScope /rsi :movqImmReg
      /rsi /rsi :movqMemReg
      # TODO: put a type here where applicable
      /rdx /rdx :xorqRegReg

      internalAllocateFunction /rax :movqImmReg
      /rax :callqReg
      /rax :pushqReg

      # create string
      name "ey(.*)" regex assert constStringCode _ len dearray

      # enter into current (i.e. global) scope
      eydeff /rax :movqImmReg
      /rax :callqReg
    } each
  ] :execute

  <
    [
      32 { "." } rep
      " " "!" "\"" "#" "$" "%" "&" "´" "(" ")" "*" "+" "," "-" "." "/"
      /0 /1 /2 /3 /4 /5 /6 /7 /8 /9 ":" ";" "<" "=" ">" "?"
      "@" /A /B /C /D /E /F /G /H /I /J /K /L /M /N /O /P
      /Q /R /S /T /U /V /W /X /Y /Z "[" "\\" "]" "^" "_"
      "`" /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p
      /q /r /s /t /u /v /w /x /y /z "{" "|" "}" "~" "."
      128 { "." } rep
    ] /ASCII defv

    { # ==addr
      [ -01 7 add 8 { _ sys .asm .peek -01 1 sub } rep -- ] { -01 256 mul add } fold
    } /peekImm64 deff

    { # ==addr
      [ -01 3 add 4 { _ sys .asm .peek -01 1 sub } rep -- ] { -01 256 mul add } fold
    } /peekImm32 deff

    { # ==addr
      sys .asm .peek
    } /peekImm8 deff

    [ /0 /1 /2 /3 /4 /5 /6 /7 /8 /9 /A /B /C /D /E /F ] ==base16singleDigits
    [ base16singleDigits { ==first base16singleDigits { first -01 cat } each } each ] ==base16digits

    {
      [ -01 8 { _ 256 mod -01 256 div } rep -- ]
      base16digits *
      reverse |cat fold
    } /base16encode64 deff

    {
      [ -01 4 { _ 256 mod -01 256 div } rep -- ]
      base16digits *
      reverse |cat fold
    } /base16encode32 deff

    { ==objAddr
      "  int\n" sys .out .writestr
    } /intDump deff

    { ==objAddr
      "  \"" sys .out .writestr
      objAddr 16 add peekImm64 ==length
      objAddr 24 add _ length add 1 sub range peekImm8 ASCII * |cat fold sys .out .writestr
      "\"\n" sys .out .writestr
    } /stringDump deff

    { ==objAddr
      "  scope\n" sys .out .writestr

      objAddr       peekImm32
      objAddr 4 add peekImm32 16777215 band 4294967296 mul add ==length

      objAddr 8 add peekImm64 ==nameTable
      objAddr 16 add peekImm64 ==parent
      objAddr 24 add peekImm64 ==extensionArea

      nameTable 8 add peekImm64 ==nameTableEnd
      16 { _ nameTableEnd lt } {
        _ nameTable add base16encode64 ": " cat sys .out .writestr
        _ nameTable add peekImm64 stringDump
        _ 16 sub 2 div 32 add _ length lt { ==offset
            offset objAddr add peekImm64 memDump
          } {
            "Extension area dumping not yet implemented" die
          } ? *
        16 add
      } loop --
    } /scopeDump deff

    { ==objAddr
      "  nameTable\n" sys .out .writestr
    } /nameTableDump deff

    { ==objAddr
      "  extensionArea\n" sys .out .writestr
    } /extensionAreaDump deff

    { ==objAddr
      "  function\n" sys .out .writestr
    } /functionDump deff

    { ==objAddr
      "  code\n" sys .out .writestr
    } /codeDump deff

    { ==addr
      [
        "  "
        addr base16encode64
        ": "
        # the perl interpreter does not like full 64bit numbers and converts them into floats
        addr 4 add peekImm32 _ ==heapValueB base16encode32
        addr       peekImm32 _ ==heapValueA base16encode32
        " "
        [ [ heapValueA heapValueB ] { 4 { _ 256 mod -01 256 div } rep -- } each ] ASCII * 8 dearray
        "\n"
      ] |cat fold sys .out .writestr
    } /memDump deff

    { ==objAddr
      "Object at " objAddr base16encode64 cat " ----------\n" cat sys .out .writestr
      objAddr       peekImm32
      objAddr 4 add peekImm32 16777215 band 4294967296 mul
        add 8 div ==length
      0 length 1 sub range { 8 mul objAddr add memDump } each

      objAddr 7 add peekImm8 16 div
      [
        |intDump |stringDump |scopeDump |nameTableDump |extensionAreaDump |functionDump |codeDump |die
        |die |die |die |die |die |die |die |die
      ] *
      objAddr -01*
      "^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" sys .out .writestr
    } /heapDump deff

    {
      :mainStack .base :STACKSIZE add ==stackEnd
      "Stack ------------\n" sys .out .writestr
      :mainStack .base peekImm64 ==addr
      addr stackEnd gt { [ -01 stackEnd ] die } rep # Stack corrupted

      { addr stackEnd lt } {
        [
          addr base16encode64 ": "
          addr peekImm64 ==value
          value base16encode64
          "\n"
        ] |cat fold sys .out .writestr

        value 105553116266496 ge value 123145302310912 lt and {
          value       peekImm32
          value 4 add peekImm32 16777215 band 4294967296 mul
            add 8 div ==length
          0 length 1 sub range { 8 mul value add memDump } each
        } rep
        addr 8 add =addr
      } loop
      "^^^^^^^^^^^^^^^^^^\n" sys .out .writestr
    } /stackDump

    {
      currentScope peekImm64 heapDump
    } /globalScopeDump
  > -- 2 |deff rep
> /assemblerLibrary defv

# vim: syn=elymas
