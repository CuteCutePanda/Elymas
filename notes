RegEx stuff: http://sebfisch.github.com/haskell-regexp/

= Expressions =

0 1 2...  -> just push themselves on the stack
"string"  -> pushes "string" on the stack
<non-bareword><bareword> -> "bareword" <non-bareword>
  /bareword -> "bareword" /
  |bareword -> "bareword" |
  \bareword -> "bareword" \

bareword  -> lookup "bareword" in current scopes
  -> passive -> push value on the stack
  -> active  -> call value on current stack
  -> quote   -> call value on current stack, even in quoted mode

/ -> nop
"string" | -> resolve "string" in current scope, push value
"string" \ -> resolve "string" in current scope, call value on current stack

[ -> push array begin marker on stack
] -> since the topmost array marker, create array from stack values

( -> push tuple begin marker on stack
) -> since the topmost tuple marker, create tuple from stack values

{ -> push quote begin marker on stack, increase parser quote count
} -> since the topmost quote marker, everything becomes one closure (deduce type), decrease parser quote count

dup -> dups
|dup -> push dup function pointer
\dup -> dups

|f |g ; -> { f g }
{ ...1 } variable ; { ...2 } ; -> { ...1 variable } { ...2 } ; -> { ...1 variable ...2 }
1 2 |add * -> 3

|f * -> f
|f *10 g -> f <copy the former _10> g

StructuredData.field -> StructuredData "field" . -> dereference field in structured data, if passive push, if active do
SD "field" .| -> dereference, push value
SD "field" .\ -> dereference, call

x "string" =    -> dereference, create (passive/active depends on type) field if not existent, set value to x
x pointer =     -> dereference, set value to x
x /pointervar = -> sets the pointer itself
x |pointervar = -> sets the value the pointer points to
x \pointervar = -> if the pointer points to a value which is a pointer, assign where that pointer points to

v "name" deff -> define name as active name, assign v
v "name" defv -> define name as passive name, assign v

< -> push new scope
> -> pop scope, structured data object now on stack
< 0 =a 0 =b > -> something which has a and b is on top of stack

0 1 2 _0 -> 0 1 2 2
0 1 2 _1 -> 0 1 2 1
0 1 2 _2 -> 0 1 2 0
0 1 2 -0 -> 2
0 1 2 -1 -> 1
0 1 2 -2 -> 0

exch = -01
pop = -
nop = _
dup = _0
_<digits> -> copy stack contents according to digits
-<digits> -> delete stack contents up to largest digit or count of "-" whichever is larger, recreate according to digits

1 [ 2 3 ] add -> [ 3 4 ]
[ [ 1 ] [ 2 ] ] length -> 2     # scanning for applicable base type from top

A->int B->int add    ->  B->A->int
A->int A->int add    ->  A->int

= Characters =

!: <open>
": string quote
#: line comment
$: <open>
%: <open>
&: <open>
': <open>
(: tuple begin
): tuple end
*: apply function
+: <open>
,: <open>
-: stack manipulation
.: field dereference
/: stringify
0-9: numbers
:: <open>
;: function composition
<: scope start
=: assignment
>: scope end
?: ternary operator
@: <open>
A-Z: bareword characters
[: array begin
\: callify
]: array end
^: <open>
_: stack manipulation
`: <open>
a-z: bareword characters
{: quote begin
|: passify
}: quote end
~: <open>


= Memory Management =

Inspiration: http://wiki.luajit.org/new-garbage-collector

0x6???????????: Heap memory ("16 TB should be enough for everyone.")
0x5???????????: GC black bitmap
0x4???????????: GC allocation maps

Large set of reachable, old objects
Large set of unreachable, new objects
Small set in between


== Object Memory Layout ==

=== Int ===
* Length in bytes (including header, always 16)
  bit 63-60: 0 0 0 0
  bit 59: reserved for GC
* value

=== String ===
* Length in bytes (including header)
  bit 63-60: 0 0 0 1
  bit 59: reserved for GC
* hash (0 if not yet calculated)
* Exact length
* data (UTF-8)

=== Struct ===
* Length in bytes (including header)
  bit 63-60: 0 0 1 0
  bit 59: reserved for GC
  bit 58: parent pointer exists (for scopes)
  bit 57: extension area pointer exists
* hashtable name -> offset including headers
* parent scope (0 if no parent)
* extension area pointer (0 if no extra members (yet))
* data
